// Author: cvet
#include "_macros.fos"
#include "_msgstr.fos"
#include "_teams.fos"
#include "_npc_pids.fos"
#include "teams_table.fos"
#include "npc_ai.fos"

// Imports
import bool OnUseExplode(Critter& cr, Item& explode, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint timer) from "explode";
import bool UseItemOnCar(Critter& cr, Item& car, Item& item) from "car";
import bool UseSkillOnCar(Critter& cr, Item& car, int skill) from "car";
import void WorldmapInit() from "worldmap";
import void FindEncounter(Critter@[]& group, Item@ car, uint x, uint y, uint& encounterDescriptor, bool& waitForAnswer, bool empty) from "worldmap";
import void InviteToEncounter(Critter@[]& group, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir) from "worldmap";
import void SetStartLocation(Critter& cr) from "replication";
import void SetReplicationTime(Critter& cr) from "replication";
import void ReplicateCritter(Critter& cr) from "replication";
import void CombatAttack(Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo) from "combat";
import bool TryRepairItem(Critter& cr, Item& item) from "repair";
import bool WantedSignSet(Item& wantedSign, string& name, uint cost) from "wanted";
import bool IsReadableBook(uint16 pid) from "books";
import void TryReadBook(Critter& cr, Item& book) from "books";
import void UseDrug(Critter& cr, Item& drug) from "drugs";
import void UseDrugOn(Critter& cr, Critter& onCr, Item& drug) from "drugs";
import bool UseGeiger(Critter& cr, Item& geiger) from "geiger";
import bool UseItemOnGeiger(Critter& cr, Item& geiger, Item& item) from "geiger";
import bool UseSkillOnGeiger(Critter& cr, Item& geiger, int skill) from "geiger";
import bool AddWalkPlane(Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut) from "npc_planes";
import void CallTownSupply(Critter& victim, Critter& hostile) from "town_supply";
import bool AddAttackPlane(Critter& npc, uint priority, Critter& target) from "npc_planes";
import bool AddAttackPlane(Critter& npc, uint priority, Critter& target, int minHp) from "npc_planes";
import bool IsKeyAviable(Critter& cr, uint lockerId) from "lockers";
import uint GetKeyId(Critter& cr, uint lockerId) from "lockers";
import bool UseSkillOnLocker(Critter& cr, Item& locker, int skill) from "lockers";
import bool PerkCheck(Critter& cr, uint perk) from "perks";
import void CritterGenerate(Critter& cr) from "parameters";
import void CaravansInit() from "caravan";
import int GetWearProcent(Item& item) from "repair";
import void SetWear(Item& item, int wearProcent) from "repair";
import void NpcProcessLevel(Critter& npc) from "parameters";
import bool IsPermanentDeath(uint id) from "replication";
import bool SetPlayerStoryLineLocation(Critter & player)  from "q_main_intro";

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on start server.
bool start()
{
#include "start_server_client.fos"

	// Send info about others critters
	// Remember:
	// - all this info can be hacked in client;
	// - more parameters - more traffic.
	SetSendParameter(ST_GENDER,true);
	SetSendParameter(ST_AGE,true);
	SetSendParameter(ST_FOLLOW_CRIT,true);
	SetSendParameter(ST_PLAYER_KARMA,true);
	// Armor class, uses Agility
	SetSendParameter(ST_ARMOR_CLASS,true);
	SetSendParameter(ST_TURN_BASED_AC,true);
	// Agility
	SetSendParameter(ST_AGILITY,true);
	// Hit points, uses Strenght and Endurance
	SetSendParameter(ST_MAX_LIFE,true);
	SetSendParameter(ST_CURRENT_HP,true);
	// Strenght, uses battle timeout
	SetSendParameter(ST_STRENGTH,true);
	SetSendParameter(PE_ADRENALINE_RUSH,true);
	// Battle timeout
	SetSendParameter(TO_BATTLE,true);
	// Endurance
	SetSendParameter(ST_ENDURANCE,true);
	// Injures
	SetSendParameter(DAMAGE_EYE,true);
	SetSendParameter(DAMAGE_RIGHT_ARM,true);
	SetSendParameter(DAMAGE_LEFT_ARM,true);
	SetSendParameter(DAMAGE_RIGHT_LEG,true);
	SetSendParameter(DAMAGE_LEFT_LEG,true);
	// Item slots, passed with -
	SetSendParameter(-SLOT_HAND1,true,"fonline_tla.dll@_AllowSlotHand1");
	SetSendParameter(-SLOT_ARMOR,true);
	// Some flags for correct client working
	SetSendParameter(MODE_NO_BARTER,true);
	SetSendParameter(MODE_NO_STEAL,true);
	SetSendParameter(MODE_NO_LOOT,true);
	SetSendParameter(MODE_NO_FLATTEN,true);
	// 3d animation layers
	//for(uint i=ST_ANIM3D_LAYERS;i<=ST_ANIM3D_LAYERS+15;i++) SetSendParameter(i,true); // From Skin to Backpack
	// Npc talk distance
	SetSendParameter(ST_TALK_DISTANCE,true);
	// Dialog id
	SetSendParameter(ST_DIALOG_ID,true);
	// To see pid of unarmed attack
	SetSendParameter(ST_HANDS_ITEM_AND_MODE,true);
	// Scale factor
	SetSendParameter(ST_SCALE_FACTOR,true);

	// Send item data masks
	//              SortValue Info Reserved0 PicMapHash   PicInvHash   AnimWaitBase AnimStay[2] AnimShow[2] AnimHide[2] Flags        Rate LightIntensity LightDistance LightFlags LightColor   ScriptId TrapValue Count        Cost         ScriptValues[10]                                                                          Shared data 8 bytes
	// ITEM_DATA_MASK_CHOSEN                                                                                           ITEM_DATA_MASK_CHOSEN                                                                                                ITEM_DATA_MASK_CHOSEN
	int8[] mask0={  -1,-1,     -1,    0,     -1,-1,-1,-1, -1,-1,-1,-1,    0,0,         0,  0,      0,  0,      0,  0,   -1,-1,-1,-1,  -1,       -1,            -1,        -1,     -1,-1,-1,-1,   0,0,     0,0,    -1,-1,-1,-1, -1,-1,-1,-1, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, -1,-1,-1,-1,-1,-1,-1,-1 };
	// ITEM_DATA_MASK_CRITTER                                                                                           ITEM_DATA_MASK_CRITTER                                                                                               ITEM_DATA_MASK_CRITTER
	int8[] mask1={    0,0,     -1,    0,         0,0,0,0,     0,0,0,0,    0,0,         0,  0,      0,  0,      0,  0,   -1,-1,-1,-1,  -1,       -1,            -1,        -1,     -1,-1,-1,-1,   0,0,     0,0,        0,0,0,0,     0,0,0,0, 0,0,0,0 ,0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,         0,0,0,0,0,0,0,0 };
	// ITEM_DATA_MASK_CRITTER_EXT                                                                                      ITEM_DATA_MASK_CRITTER_EXT                                                                                           ITEM_DATA_MASK_CRITTER_EXT
	int8[] mask2={    0,0,     -1,    0,         0,0,0,0,     0,0,0,0,    0,0,         0,  0,      0,  0,      0,  0,   -1,-1,-1,-1,  -1,       -1,            -1,        -1,     -1,-1,-1,-1,   0,0,     0,0,    -1,-1,-1,-1,     0,0,0,0, 0,0,0,0 ,0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, -1,-1,-1,-1,-1,-1,-1,-1 };
	// ITEM_DATA_MASK_CONTAINER                                                                                        ITEM_DATA_MASK_CONTAINER                                                                                             ITEM_DATA_MASK_CONTAINER
	int8[] mask3={  -1,-1,     -1,    0,         0,0,0,0, -1,-1,-1,-1,    0,0,         0,  0,      0,  0,      0,  0,   -1,-1,-1,-1,  -1,       -1,            -1,        -1,     -1,-1,-1,-1,   0,0,     0,0,    -1,-1,-1,-1, -1,-1,-1,-1, 0,0,0,0 ,0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, -1,-1,-1,-1,-1,-1,-1,-1 };
	// ITEM_DATA_MASK_MAP                                                                                              ITEM_DATA_MASK_MAP                                                                                                   ITEM_DATA_MASK_MAP
	int8[] mask4={  -1,-1,     -1,    0,     -1,-1,-1,-1,     0,0,0,0,  -1,-1,        -1, -1,     -1, -1,     -1, -1,   -1,-1,-1,-1,  -1,       -1,            -1,        -1,     -1,-1,-1,-1,   0,0,     0,0,        0,0,0,0,     0,0,0,0, 0,0,0,0 ,0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, -1,-1,-1,-1,-1,-1,-1,-1 };
	SetItemDataMask(ITEM_DATA_MASK_CHOSEN,mask0);
	SetItemDataMask(ITEM_DATA_MASK_CRITTER,mask1);
	SetItemDataMask(ITEM_DATA_MASK_CRITTER_EXT,mask2);
	SetItemDataMask(ITEM_DATA_MASK_CONTAINER,mask3);
	SetItemDataMask(ITEM_DATA_MASK_MAP,mask4);

	WorldmapInit();
	CaravansInit();
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on world initialization.
// Parameter         Min    Max
// multiplier        1      50000
// year              1700   30000
// month             1      12
// day               1      31
// hour              0      23
// minute            0      59
void get_start_time(uint16& multiplier, uint16& year, uint16& month, uint16& day, uint16& hour, uint16& minute)
{
	multiplier=20;
	year=2246;
	month=10;
	day=30;
	hour=1;
	minute=0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on finish server.
void finish()
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call every returned value, in milliseconds.
// Return next call in milliseconds or zero to disable loop.
uint loop()
{
	return 0; // Disable
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Output:
//  Critter& cr - who called this function, in most times is leader of group;
//  x,y - current position;
//  toX, toY - destination position;
//  speed - speed of group, must set in GLOBAL_PROCESS_SET_MOVE; also you can type -1 to stop group;
//  if encounterDescriptor != 0 than global_invite calls;
//  if waitForAnswer == false than global_invite calls after this function, else call after leader confirm invite;
// Call types see in Global map events in _defines.fos
void global_process(int type, Critter& cr, Critter@[]& group, Item@ car, uint& x, uint& y, uint& toX, uint& toY, uint& speed, uint& encounterDescriptor, bool& waitForAnswer)
{
	int walkType=(valid(car)?car.Proto.Car_WalkType:GM_WALK_GROUND);

	if(type==GLOBAL_PROCESS_MOVE)
	{
		// Validate charisma
		Critter@ leader=group[0];
		if(int(group.length())>leader.Stat[ST_CHARISMA]+leader.Perk[PE_MAGNETIC_PERSONALITY])
		{
			leader.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_CRIT_BAD_CHARISMA);
			speed=uint(-1); // Stop
			return;
		}

		// Try find encounter
		if(::GetGlobalMapRelief(x,y)!=GM_RELIEF_WATER)
			FindEncounter(group,car,x,y,encounterDescriptor,waitForAnswer,false);
	}
	else if(type==GLOBAL_PROCESS_ENTER)
	{
		// Enter to empty encounter
		if(walkType==GM_WALK_WATER)
		{
			// Find land
			const int maxx=__GlobalMapWidth*__GlobalMapZoneLength;
			const int maxy=__GlobalMapHeight*__GlobalMapZoneLength;
			for(int ox=-1;ox<=1;ox++)
			{
				for(int oy=-1;oy<=1;oy++)
				{
					int xx=x+ox;
					int yy=y+oy;
					if(xx>=0 && xx<maxx && yy>=0 && yy<maxy && GetGlobalMapRelief(xx,yy)!=GM_RELIEF_WATER)
					{
						FindEncounter(group,car,x,y,encounterDescriptor,waitForAnswer,true);
						ox=oy=2; // Exit from loop
					}
				}
			}
		}
		else if(GetGlobalMapRelief(x,y)!=GM_RELIEF_WATER)
		{
			FindEncounter(group,car,x,y,encounterDescriptor,waitForAnswer,true);
		}
	}
	else if(type==GLOBAL_PROCESS_SET_MOVE)
	{
		// Validate charisma
		Critter@ leader=group[0];
		if(int(group.length())>leader.Stat[ST_CHARISMA]+leader.Perk[PE_MAGNETIC_PERSONALITY])
		{
			leader.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_CRIT_BAD_CHARISMA);
			return;
		}

		// Calculate speed
		speed=GLOBAL_MAP_BASE_SPEED;
		if(cr.GetAccess()>=ACCESS_TESTER) speed*=20; // All, exclude clients have highly speed

		if(valid(car))
		{
			// Validate car
			uint strNum=0;
			if(group.length()>_CarGetCritCapacity(car)) strNum=STR_CAR_CRIT_OVERLOAD;
			else if(car.CarFuel==0) strNum=STR_CAR_FUEL_EMPTY;
			else if(car.CarDeteoration>=_CarGetRunToBreak(car)) strNum=STR_CAR_BROKEN;
			if(strNum!=0)
			{
				leader.SayMsg(SAY_NETMSG,TEXTMSG_GAME,strNum);
				speed=0;
				return;
			}

			speed=car.Proto.Car_Speed*GLOBAL_MAP_BASE_SPEED/20;

			// Find near water for boats
			// In radius of one zone (left, top, right, bottom)
			if(car.Proto.Car_WalkType==GM_WALK_WATER)
			{
				if(::GetGlobalMapRelief(x,y)!=GM_RELIEF_WATER)
				{
					const int maxx=__GlobalMapWidth*__GlobalMapZoneLength;
					const int maxy=__GlobalMapHeight*__GlobalMapZoneLength;
					const int[] ox={-1,0,1,0};
					const int[] oy={0,-1,0,1};
					for(int i=1,ii=__GlobalMapZoneLength;i<=ii;i++)
					{
						for(int j=0;j<4;j++)
						{
							int xx=x+ox[j]*i;
							int yy=y+oy[j]*i;
							if(xx>=0 && xx<maxx && yy>=0 && yy<maxy && ::GetGlobalMapRelief(xx,yy)==GM_RELIEF_WATER)
							{
								x=uint(xx);
								y=uint(yy);
								// Exit from loop
								j=4;
								i=ii;
							}
						}
					}
				}
			}
		}
		else
		{
			// Pathfinder perk bonus
			int speedDiv=100-cr.Perk[PE_PATHFINDER]*25;
			if(speedDiv<=0) speedDiv=1;
			speed=speed*100/speedDiv;
		}
	}
	else if(type==GLOBAL_PROCESS_NPC_IDLE)
	{
		// Critter& cr - is npc who call idle
		// Process npc group on global map
		if(x==toX && y==toY) // Stopped
		{
			// if you want enter to location under group than type
			// encounterDescriptor=uint(-1);
			// waitForAnswer=false;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on invite to encaunter.
// If mapId != 0 than group enter to it.
void global_invite(Critter@[]& group, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir)
{
	if(encounterDescriptor==uint(-1))
	{
		Critter@ leader=group[0];
		Location@[] locations;
		if(GetLocations(leader.WorldX,leader.WorldY,0,locations)!=0)
		{
			Location@ loc=locations[0];
			Map@ map=loc.GetMapByIndex(0);
			if(valid(map) && map.GetEntireCoords(0,0,hexX,hexY))
			{
				mapId=map.Id;
				dir=0xFF;
			}
		}
		return;
	}

	InviteToEncounter(group,car,encounterDescriptor,combatMode,mapId,hexX,hexY,dir);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attack(Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo)
{
	cr.TimeoutBase[TO_AGGRESSOR]=__FullSecond+REAL_MINUTE(1);
	CombatAttack(cr,target,weapon,weaponMode,ammo);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attacked(Critter& cr, Critter& attacker)
{
	if(cr.IsPlayer()) return; // Diable player helping
	else AddAttackPlane(cr,0,attacker); // Answer on attack
	//if(cr.Timeout[TO_AGGRESSOR]>0) return;

	uint helpers=0;
	uint maxHelpers=10-attacker.Stat[ST_CHARISMA];
	maxHelpers=CLAMP(maxHelpers,2,8);

	Critter@[] critters;
	cr.GetCritters(true,FIND_LIFE_AND_KO|FIND_ONLY_NPC,critters);
	for(uint i=0,j=critters.length();i<j;i++)
	{
		NpcPlane@ plane=critters[i].GetCurPlane();
		if(valid(plane) && plane.Type==AI_PLANE_ATTACK && plane.Attack_TargId==attacker.Id)
		{
			helpers++;
			if(helpers>=maxHelpers) return; // No help needed
			@critters[i]=null; // Exclude this critter
		}
	}

	int crHpProc=cr.Stat[ST_CURRENT_HP]*100/cr.Stat[ST_MAX_LIFE];
	uint teamId=cr.Stat[ST_TEAM_ID];
	uint attackerTeamId=attacker.Stat[ST_TEAM_ID];
	for(uint i=0,j=critters.length();i<j;i++)
	{
		Critter@ someCr=critters[i];
		if(not valid(someCr)) continue; // Skip excluded

		uint someCrTeamId=someCr.Stat[ST_TEAM_ID];
		if(attackerTeamId==someCrTeamId) continue; // No attack temmate

		int teamParity=TEAM_PARITY(someCrTeamId,teamId); // From -> To
		switch(teamParity)
		{
		case Ignore: continue;
		case Anyway: break;
		case NotBusy: if(someCr.IsCurPlane(AI_PLANE_ATTACK)) continue; break;
		case HpLess10: if(crHpProc>=10) continue; break;
		case HpLess30: if(crHpProc>=30) continue; break;
		case HpLess50: if(crHpProc>=50) continue; break;
		case IfDead: if(not cr.IsDead()) continue; break;
		case GoodPerson: if(attacker.IsNpc() || cr.Stat[ST_CHARISMA]<5 || cr.Stat[ST_KARMA]<0) continue; break;
		default: continue;
		}

		AddAttackPlane(someCr,0,attacker);
		helpers++;
		if(helpers>=maxHelpers) break; // Enough
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter steal another.
bool critter_stealing(Critter& cr, Critter& thief, Item& item, uint count)
{
	thief.TimeoutBase[TO_AGGRESSOR]=__FullSecond+REAL_MINUTE(1);

	if(cr.IsDead() || cr.Timeout[TO_BATTLE]>0 || thief.Timeout[TO_BATTLE]>0)
	{
		thief.StatBase[ST_LAST_STEAL_CR_ID]=0;
		thief.StatBase[ST_STEAL_COUNT]=0;
		return false;
	}

	int dir1=cr.Dir;
	int dir2=thief.Dir;
	int kDir=MAX(dir1,dir2)-MIN(dir1,dir2);
	if(kDir>3) kDir=6-kDir;

	int steal=thief.Skill[SK_STEAL];
	if(steal<=0) steal=1;
	int size=item.Proto.Volume;
	if(size<=0) size=1;

	// Perk pickpocket, ignore size and facing
	if(thief.Perk[PE_PICKPOCKET]!=0)
	{
		kDir=0;
		size=1;
	}

	// Count modifier
	int kCount=count/steal;
	if(kCount<=0) kCount=1;

	// Check time of stealing
	uint lastStealCrId=thief.Stat[ST_LAST_STEAL_CR_ID];
	uint stealCount=thief.Stat[ST_STEAL_COUNT];
	if(lastStealCrId==cr.Id && thief.Timeout[TO_STEALING]>0) steal-=steal*stealCount*9/100;

	// Calc
	int k=(steal-kDir*10)/(size*kCount);
	k=CLAMP(k,5,95);
	bool success=!(Random(1,100)>k);

	if(success)
	{
		// Add experience     10,30,60,100,150,210,280,360,450,550,660,780
		const int[] stealExp={10,20,30,40, 50, 60, 70, 80, 90, 100,110,120};

		if(lastStealCrId==cr.Id && thief.Timeout[TO_STEALING]>0)
		{
			stealCount++;
			if(stealCount>11) stealCount=11;
			thief.StatBase[ST_STEAL_COUNT]=stealCount;
		}
		else
		{
			thief.StatBase[ST_LAST_STEAL_CR_ID]=cr.Id;
			thief.StatBase[ST_STEAL_COUNT]=0;
		}

		thief.TimeoutBase[TO_STEALING]=STEAL_TIMEOUT(thief);
		if(cr.IsNpc())
		{
			GameVar@ stealExpCount=::GetUnicumVar(UVAR_steal_exp_count,cr.Id,thief.Id);
			if(stealExpCount<12)
			{
				thief.StatBase[ST_EXPERIENCE]+=stealExp[stealCount];
				thief.AddScore(SCORE_THIEF,1);
			}
			stealExpCount=stealExpCount+1;
		}
	}
	else
	{
		thief.StatBase[ST_LAST_STEAL_CR_ID]=0;
		thief.StatBase[ST_STEAL_COUNT]=0;

		if(cr.IsNpc())
		{
			int thiefHp=thief.Stat[ST_CURRENT_HP];
			AddAttackPlane(cr,0,thief,thiefHp<10 || Random(1,10)>cr.Stat[ST_LUCK]+4 || cr.Stat[ST_CHARISMA]<3?__DeadHitPoints:Random(thiefHp/4,thiefHp/2));
		}
	}

	return success;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use item.
bool critter_use_item(Critter& cr, Item& item, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint param)
{
	bool isPlayer=cr.IsPlayer();
	uint16 pid=item.GetProtoId();
	bool useOnSelf=(not valid(targetCr) && not valid(targetItem) && not valid(targetScen));

	// Book reading
	if(useOnSelf && IsReadableBook(pid))
	{
		TryReadBook(cr,item);
		return true;
	}

	// Explosion
	if(OnUseExplode(cr,item,targetCr,targetItem,targetScen,param)) return true;

	// Cars
	if(valid(targetItem) && targetItem.IsCar() && UseItemOnCar(cr,targetItem,item)) return true;

	// Drugs
	if(item.GetType()==ITEM_DRUG)
	{
		if(useOnSelf) UseDrug(cr,item);
		else if(valid(targetCr)) UseDrugOn(cr,targetCr,item);
		else cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_USE_NOTHING);
		return true;
	}

	// Play dice
	if (pid==PID_DICE)
	{
		cr.SayMsg(SAY_EMOTE_ON_HEAD,TEXTMSG_TEXT,STR_DICE_THROW,"$result"+Random(1,6));
		return true;
	}
	if (pid==PID_LOADED_DICE)
	{
		cr.SayMsg(SAY_EMOTE_ON_HEAD,TEXTMSG_TEXT,STR_DICE_THROW,"$result"+uint((item.Id % 6)+1));
		return true;
	}

	// Magic ball
	if (pid==PID_MAGIC_8_BALL)
	{
		cr.SayMsg(SAY_EMOTE_ON_HEAD,TEXTMSG_TEXT,Random(1,2)==1?STR_MAGIC_BALL_YES:STR_MAGIC_BALL_NO);
		return true;
	}

	// Cosmetic
	if (pid==PID_COSMETIC_CASE && cr.Stat[ST_GENDER]==GENDER_FEMALE)
	{
		cr.SayMsg(SAY_EMOTE_ON_HEAD,TEXTMSG_TEXT,STR_COSMETIC_USE);
		return true;
	}

	// Cigarettes smoking
	if (pid==PID_CIGARETTES && _CritCountItem(cr,PID_LIGHTER)>0)
	{
		cr.SayMsg(SAY_EMOTE_ON_HEAD,TEXTMSG_TEXT,STR_CIGARETTES_SMOKE);
		return true;
	}

	// Geiger counter
	if(pid==PID_GEIGER_COUNTER && useOnSelf && UseGeiger(cr,item)) return true;
	if(valid(targetItem) && targetItem.GetProtoId()==PID_GEIGER_COUNTER && UseItemOnGeiger(cr,targetItem,item)) return true;

	// Take process to engine
	return false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use skill.
bool critter_use_skill(Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen)
{
	bool isPlayer=cr.IsPlayer();

	// Cars
	if(valid(targetItem) && targetItem.IsCar() && UseSkillOnCar(cr,targetItem,skill)) return true;

	// Geiger counter
	if(valid(targetItem) && targetItem.GetProtoId()==PID_GEIGER_COUNTER && UseSkillOnGeiger(cr,targetItem,skill)) return true;

	// Doors or containers
	if(valid(targetItem) && (targetItem.GetType()==ITEM_DOOR || targetItem.GetType()==ITEM_CONTAINER) && UseSkillOnLocker(cr,targetItem,skill)) return true;

	switch(skill)
	{
	case SKILL_PICK_ON_GROUND: // Pick item or scenery on ground
		{
			// Scenery
			if(valid(targetScen))
			{
				cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_USE_NOTHING);
				return true;
			}

			// Wanted
			if(valid(targetItem) && targetItem.GetProtoId()==PID_WANTED_SIGN && WantedSignSet(targetItem,cr.Name,Random(1000,2000))) return true;
			// Explosion
			if(valid(targetItem) && targetItem.GetProtoId()==PID_ACTIVE_MINE && OnUseExplode(cr,targetItem,null,null,null,0)) return true;

			// Pick some item
			if(valid(targetItem))
			{
				Item@ item=targetItem;
				if(not FLAG(item.Flags,ITEM_CAN_PICKUP))
				{
					cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_USE_NOTHING);
					break;
				}

				int freeWeight=cr.Stat[ST_CARRY_WEIGHT]-cr.ItemsWeight();
				if(freeWeight>=int(item.Proto.Weight*item.GetCount()))
				{
					// Pick full
					MoveItem(item,0,cr);
				}
				else
				{
					// Pick half
					if(item.IsGrouped() && freeWeight>=int(item.Proto.Weight)) MoveItem(item,freeWeight/item.Proto.Weight,cr);
					// Overweight
					else cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_OVERWEIGHT);
				}
			}
		}
		break;
	case SKILL_PUT_CONT: // Put item in container, only targetItem is valid
	case SKILL_TAKE_CONT: // Take item from container, only targetItem is valid
	case SKILL_TAKE_ALL_CONT: // Take all items from critter or item container
		return false; // Allow transactions
	case SKILL_LOOT_CRITTER: // Loot critter, only targetCr is valid
		cr.Action(ACTION_PICK_CRITTER,0,null);
		cr.ShowContainer(targetCr,null,TRANSFER_CRIT_LOOT);
		return true;
	case SKILL_PUSH_CRITTER: // Push critter, only targetCr is valid
		cr.Action(ACTION_PICK_CRITTER,2,null);
		if((cr.Timeout[TO_BATTLE]==0 && targetCr.Timeout[TO_BATTLE]==0) &&
			(targetCr.IsPlayer() || (targetCr.IsNoPlanes() && targetCr.GetTalkedPlayers(null)==0))) targetCr.MoveRandom();
		return true;
	case SK_SCIENCE:
		{
			cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_USE_NOTHING); // Todo: "You fail to learn anything."
		}
		break;
	case SK_REPAIR:
		{
			// Generic repair
			if(valid(targetItem) && targetItem.Accessory==ACCESSORY_CRITTER && targetItem.IsWeared() && TryRepairItem(cr,targetItem)) return true;

			cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_USE_NOTHING);
		}
		break;
	case SK_SNEAK:
		{
			if(cr.Mode[MODE_HIDE]!=0) cr.ModeBase[MODE_HIDE]=0;
			else if(not isPlayer) cr.ModeBase[MODE_HIDE]=1;
			else
			{
				if(cr.Timeout[TO_SNEAK]>0) cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_TIMEOUT_SNEAK_WAIT);
				else if(IS_TURN_BASED_TIMEOUT(cr)) cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_TIMEOUT_BATTLE_WAIT);
			//	else if(cr.GetCritters(true,FIND_LIFE,null)>0)
			//	{
			//		cr.TimeoutBase[TO_SNEAK]=SNEAK_TIMEOUT(cr);
			//		cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_SNEAK_VISIBLE);
			//	}
				else cr.ModeBase[MODE_HIDE]=1;
			}
		}
		break;
	case SK_STEAL:
		{
			if(valid(targetItem))
			{
				cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_USE_NOTHING);
			}
			else if(valid(targetCr))
			{
				// Loot
				if(targetCr.IsDead())
				{
					cr.Action(ACTION_PICK_CRITTER,0,null);
					cr.ShowContainer(targetCr,null,TRANSFER_CRIT_LOOT);
				}
				// Steal
				else
				{
					if(isPlayer && cr.Timeout[TO_SK_STEAL]>0) cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_WEARINESS);
					else
					{
						cr.Action(ACTION_PICK_CRITTER,1,null);
						cr.ShowContainer(targetCr,null,TRANSFER_CRIT_STEAL);
						cr.TimeoutBase[TO_SK_STEAL]=STEAL_TIMEOUT(cr);
						cr.StatBase[ST_LAST_STEAL_CR_ID]=0;
						cr.StatBase[ST_STEAL_COUNT]=0;
					}
				}
			}
			else
			{
				cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_USE_NOTHING);
			}
		}
		break;
	case SK_FIRST_AID:
		{
			if(valid(targetItem) || valid(targetScen))
			{
				cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_USE_NOTHING);
				break;
			}

			if(not valid(targetCr)) @targetCr=cr;
			bool is_self=(targetCr.Id==cr.Id);

			if(targetCr.IsDead())
			{
				cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_NORESSURECT);
				break;
			}

			if(targetCr.Stat[ST_CURRENT_HP]>=targetCr.Stat[ST_MAX_LIFE])
			{
				if(_CritIsInjured(targetCr)) cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_NOFIRSTAID_NEEDDOCTOR);
				else if(is_self) cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_NONEED_FIRSTAID);
				break;
			}

			if(isPlayer && cr.Timeout[TO_SK_FIRST_AID]>0)
			{
				cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_WEARINESS);
				break;
			}

			int sk=cr.Skill[SK_FIRST_AID];
			uint8 mode=0;
			uint16 activePid=cr.GetSlotProto(SLOT_HAND1,mode).GetProtoId();
			if(activePid==PID_FIRST_AID_KIT)
			{
				sk+=25;
				if(Random(0,30)==0) cr.DeleteItem(PID_FIRST_AID_KIT,1);
			}
			else if(activePid==PID_FIELD_MEDIC_KIT)
			{
				sk+=50;
				if(Random(0,30)==0) cr.DeleteItem(PID_FIELD_MEDIC_KIT,1);
			}
			int mod=11-cr.Stat[ST_LUCK];
			mod=CLAMP(mod,1,10);
			int heal=Random(sk/mod,sk);
			if(heal<1) heal=1;

			int curHp=targetCr.Stat[ST_CURRENT_HP];
			int maxHp=targetCr.Stat[ST_MAX_LIFE];
			if(curHp+heal>maxHp) heal=maxHp-curHp;
			targetCr.StatBase[ST_CURRENT_HP]+=heal;

			cr.Say(SAY_NETMSG,"+"+heal);
			if(not is_self) targetCr.Say(SAY_NETMSG,"+"+heal);

			if(isPlayer)
			{
				GameVar@ firstAidCount=::GetUnicumVar(UVAR_first_aid_count,cr.Id,targetCr.Id);
				if(firstAidCount<10) cr.StatBase[ST_EXPERIENCE]+=heal*3;
				firstAidCount+=1;

				cr.TimeoutBase[TO_SK_FIRST_AID]=FIRST_AID_TIMEOUT(cr);
				cr.AddScore(SCORE_DOCTOR,1);
			}
		}
		break;
	case SK_DOCTOR:
		{
			if(valid(targetItem) || valid(targetScen))
			{
				cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_USE_NOTHING);
				break;
			}

			if(not valid(targetCr)) @targetCr=cr;
			bool is_self=(targetCr.Id==cr.Id);

			if(targetCr.IsDead())
			{
				cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_NORESSURECT);
				break;
			}

			if(not _CritIsInjured(targetCr))
			{
				if(targetCr.Stat[ST_CURRENT_HP]<targetCr.Stat[ST_MAX_LIFE]) cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_NODOCTOR_NEEDFIRSTAID);
				else if(is_self) cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_NONEED_DOCTOR);
				break;
			}

			if(isPlayer && cr.Timeout[TO_SK_DOCTOR]>0)
			{
				cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_WEARINESS);
				break;
			}

			int uninjured=0;
			int sk=cr.Skill[SK_DOCTOR];
			uint8 mode=0;
			uint16 activePid=cr.GetSlotProto(SLOT_HAND1,mode).GetProtoId();
			if(activePid==PID_DOCTORS_BAG)
			{
				sk+=25;
				if(Random(0,30)==0) cr.DeleteItem(PID_DOCTORS_BAG,1);
			}
			else if(activePid==PID_PARAMEDICS_BAG)
			{
				sk+=50;
				if(Random(0,30)==0) cr.DeleteItem(PID_PARAMEDICS_BAG,1);
			}

			for(int i=DAMAGE_EYE;i<=DAMAGE_LEFT_LEG;++i)
			{
				if(targetCr.Damage[i]!=0)
				{
					if(sk>Random(5,95))
					{
						targetCr.DamageBase[i]=0;
						cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_HEAL_DMG(i-DAMAGE_POISONED));
						uninjured++;
					}
					else
					{
						cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_NOHEAL_DMG(i-DAMAGE_POISONED));
					}
					sk/=2;
				}
			}

			if(isPlayer)
			{
				if(uninjured>0) cr.StatBase[ST_EXPERIENCE]+=uninjured*50;
				cr.TimeoutBase[TO_SK_DOCTOR]=DOCTOR_TIMEOUT(cr);
				cr.AddScore(SCORE_DOCTOR,uninjured);
			}
		}
		break;
	case SK_LOCKPICK:
		{
			// Lockers processed in lockers.fos
		}
		break;
	case SK_TRAPS:
		{
			// Explosion
			if(valid(targetItem))
			{
				uint16 pid=targetItem.GetProtoId();
				if((pid==PID_ACTIVE_DYNAMITE || pid==PID_ACTIVE_PLASTIC_EXPLOSIVE || pid==PID_ACTIVE_MINE) &&
					OnUseExplode(cr,targetItem,null,null,null,0)) return true;
			}

			cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_USE_NOTHING);
		}
		break;
	default:
		{
			cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_USE_NOTHING);
		}
		break;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reload weapon.
// If ammo is not valid than only unload.
void critter_reload_weapon(Critter& cr, Item& weapon, Item@ ammo)
{
	// Special weapons
	if(weapon.Proto.Weapon_Caliber==0)
	{
		if(weapon.GetProtoId()==PID_SOLAR_SCORCHER)
		{
			if(IS_NIGHT(__Hour)) cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SOLAR_SCORCHER_NO_LIGHT);
			else
			{
				weapon.WeaponAmmoCount=weapon.Proto.Weapon_VolumeHolder;
				weapon.Update();
			}
		}

		return;
	}

	// Other weapons
	// Unload
	if(not valid(ammo) || (weapon.WeaponAmmoCount>0 && weapon.WeaponAmmoPid!=ammo.GetProtoId()))
	{
		if(weapon.WeaponAmmoPid!=0)
		{
			Item@ existAmmo=cr.GetItem(weapon.WeaponAmmoPid,-1);
			if(not valid(existAmmo)) cr.AddItem(weapon.WeaponAmmoPid,weapon.WeaponAmmoCount);
			else _IncItem(existAmmo,weapon.WeaponAmmoCount);
		}
		weapon.WeaponAmmoCount=0;
	}

	// Load
	if(valid(ammo))
	{
		uint count=MIN(ammo.GetCount(),weapon.Proto.Weapon_VolumeHolder-weapon.WeaponAmmoCount);
		weapon.WeaponAmmoCount+=count;
		weapon.WeaponAmmoPid=ammo.GetProtoId();
		_SubItem(ammo,count);
	}

	weapon.Update();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on player register/login in game or npc created/loaded.
// Default start position for players is center of global map.
void critter_init(Critter& cr, bool firstTime)
{
	if(firstTime)
	{
		if(cr.IsPlayer())
		{
			// Input: 7 special, 3 tag skills, 2 traits, age, gender
			uint traits=0;
			for(uint i=TRAIT_BEGIN;i<=TRAIT_END;i++)
			{
				if(cr.TraitBase[i]!=0 && traits<2)
				{
					cr.TraitBase[i]=1;
					traits++;
				}
				else cr.TraitBase[i]=0;
			}

			if(cr.StatBase[ST_GENDER]<0 || cr.StatBase[ST_GENDER]>1) cr.StatBase[ST_GENDER]=0;
			if(cr.StatBase[ST_AGE]<14 || cr.StatBase[ST_AGE]>80) cr.StatBase[ST_AGE]=25;
			for(uint i=ST_STRENGTH;i<=ST_LUCK;i++) cr.StatBase[i]=CLAMP(cr.StatBase[i],1,10);

			if((cr.StatBase[ST_STRENGTH]+cr.StatBase[ST_PERCEPTION]+cr.StatBase[ST_ENDURANCE]+
				cr.StatBase[ST_CHARISMA]+cr.StatBase[ST_INTELLECT]+cr.StatBase[ST_AGILITY]+cr.StatBase[ST_LUCK])!=40)
			{
				for(uint i=ST_STRENGTH;i<=ST_LUCK;i++) cr.StatBase[i]=5;
			}

			cr.StatBase[ST_EMP_RESIST]=500;
			cr.AddHolodiskInfo(42); // Journalist's research
		}

		if(cr.TagSkill[TAG_SKILL1]<int(SKILL_BEGIN) || cr.TagSkill[TAG_SKILL1]>int(SKILL_END)) cr.TagSkillBase[TAG_SKILL1]=0;
		if(cr.TagSkill[TAG_SKILL2]<int(SKILL_BEGIN) || cr.TagSkill[TAG_SKILL2]>int(SKILL_END)) cr.TagSkillBase[TAG_SKILL2]=0;
		if(cr.TagSkill[TAG_SKILL3]<int(SKILL_BEGIN) || cr.TagSkill[TAG_SKILL3]>int(SKILL_END)) cr.TagSkillBase[TAG_SKILL3]=0;
		if(cr.TagSkill[TAG_SKILL1]==cr.TagSkill[TAG_SKILL2]) cr.TagSkillBase[TAG_SKILL1]=0;
		if(cr.TagSkill[TAG_SKILL2]==cr.TagSkill[TAG_SKILL3]) cr.TagSkillBase[TAG_SKILL2]=0;
		if(cr.TagSkill[TAG_SKILL3]==cr.TagSkill[TAG_SKILL1]) cr.TagSkillBase[TAG_SKILL3]=0;

		CritterGenerate(cr);
		cr.StatBase[ST_CURRENT_HP]=cr.Stat[ST_MAX_LIFE];
		cr.StatBase[ST_CURRENT_AP]=cr.Stat[ST_ACTION_POINTS]*100;

		for(int i=REPUTATION_BEGIN;i<=599;i++) cr.ParamBase[i]=int(0x80000000); // 599 is last number processed in client

		if(cr.IsPlayer())
		{
			for(uint i=ST_STRENGTH;i<=ST_LUCK;i++) cr.StatBase[i]=CLAMP(cr.StatBase[i],1,10);

			cr.StatBase[ST_REPLICATION_COST]=100;
			cr.StatBase[ST_REPLICATION_MONEY]=0;
			cr.StatBase[ST_REPLICATION_COUNT]=0;
			cr.ChangeCrType(cr.Stat[ST_GENDER]==GENDER_MALE?CRTYPE_DEFAULT_M:CRTYPE_DEFAULT_F);
			cr.StatBase[ST_TEAM_ID]=1;
			cr.StatBase[ST_DAMAGE_TYPE]=DAMAGE_NORMAL;

			SetStartLocation(cr);

			// Main quest
			//if(!(__MainStoryLineActive && SetPlayerStoryLineLocation(cr))) SetStartLocation(cr);
			if(__MainStoryLineActive) SetPlayerStoryLineLocation(cr);
		}
		else
		{
			cr.ChangeCrType(cr.StatBase[ST_BASE_CRTYPE]);
			if(cr.Stat[ST_LEVEL]!=0) NpcProcessLevel(cr);
		}
	}
	else
	{
		// Main quest
		if(cr.IsPlayer() && __MainStoryLineActive) SetPlayerStoryLineLocation(cr);

		// Current skin validation
		Item@ armor=cr.GetItem(0,SLOT_ARMOR);
		if(not valid(armor))
		{
			uint crType=cr.Stat[ST_BASE_CRTYPE];
			if(crType==0) crType=(cr.Stat[ST_GENDER]==GENDER_MALE?CRTYPE_DEFAULT_M:CRTYPE_DEFAULT_F);
			if(cr.CrType!=crType) cr.ChangeCrType(crType);
		}

		// Armor perk validation
		if(not valid(armor) && cr.Stat[ST_CURRENT_ARMOR_PERK]!=0)
		{
			switch(cr.Stat[ST_CURRENT_ARMOR_PERK])
			{
			case ARMOR_PERK_POWERED:
				cr.StatBase[ST_STRENGTH_EXT]-=3;
				cr.StatBase[ST_RADIATION_RESISTANCE_EXT]-=30;
				break;
			case ARMOR_PERK_COMBAT:
				cr.StatBase[ST_RADIATION_RESISTANCE_EXT]-=20;
				break;
			case ARMOR_PERK_ADVANCED_I:
				cr.StatBase[ST_STRENGTH_EXT]-=4;
				cr.StatBase[ST_RADIATION_RESISTANCE_EXT]-=60;
				break;
			case ARMOR_PERK_ADVANCED_II:
				cr.StatBase[ST_STRENGTH_EXT]-=4;
				cr.StatBase[ST_RADIATION_RESISTANCE_EXT]-=75;
				break;
			case ARMOR_PERK_CHARISMA:
				cr.StatBase[ST_CHARISMA_EXT]-=1;
				break;
			default:
				break;
			}
			cr.StatBase[ST_CURRENT_ARMOR_PERK]=0;
		}

		// Clear timeouts if too long (happens when saves got removed)
		for(uint i=TIMEOUT_BEGIN;i<=TIMEOUT_END;i++)
			 if(i!=TO_BATTLE && cr.Timeout[i]>int(MAXIMUM_TIMEOUT)) cr.TimeoutBase[i]=__FullSecond;

		// Erase zero time events
		cr.EraseTimeEvents(0);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on critter exit from game.
void critter_finish(Critter& cr, bool toDelete)
{
	if(toDelete && cr.Stat[ST_DEAD_BLOCKER_ID]!=0)
	{
		Item@ block=::GetItem(cr.Stat[ST_DEAD_BLOCKER_ID]);
		if(valid(block)) DeleteItem(block);
		cr.StatBase[ST_DEAD_BLOCKER_ID]=0;
	}
	// if(toDelete) DeleteVars(cr.Id); used engine vars garbager
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call every __CritterLoopTick time.
void critter_idle(Critter& cr)
{
	if(cr.IsDead() && cr.Stat[ST_REPLICATION_TIME]>=0 && cr.Timeout[TO_REPLICATION]==0) ReplicateCritter(cr);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter dies.
// Killer can be null.
void critter_dead(Critter& cr, Critter@ killer)
{
	Map@ map=cr.GetMap();
	// Move inventory items to ground
	if((cr.CondExt==COND_DEAD_PULSE_DUST || cr.CondExt==COND_DEAD_EXPLODE) && _CritCanDropItemsOnDead(cr))
	{
		// Drop all, exclude armor
		Item@[] items;
		cr.GetItems(SLOT_INV,items);
		cr.GetItems(SLOT_HAND1,items);
		cr.GetItems(SLOT_HAND2,items);
		if(valid(map))
		{
			// Disable drop of hidden items
			for(uint i=0,j=items.length();i<j;i++) if(FLAG(items[i].Flags,ITEM_HIDDEN)) @items[i]=null;
			MoveItems(items,map,cr.HexX,cr.HexY);
		}
		else DeleteItems(items);
	}

	// Mob drops
	uint16 npcPid=cr.GetProtoId();
	uint16 dropPid=0;
	switch(npcPid)
	{
	case NPC_PID_GoldenGecko:
	case NPC_PID_ToughGoldenGecko: if(valid(killer) && killer.Perk[PE_GECKO_SKINNING]!=0) dropPid=PID_GOLDEN_GECKO_PELT; break;
	case NPC_PID_SmallSilverGecko:
	case NPC_PID_ToughSilverGecko: if(valid(killer) && killer.Perk[PE_GECKO_SKINNING]!=0) dropPid=PID_GECKO_PELT; break;
	case NPC_PID_SmallRadscorpion:
	case NPC_PID_SmallRadscorpion2:
	case NPC_PID_LargeRadscorpion:
	case NPC_PID_LargeRadscorpion2:
	case NPC_PID_LargeRadscorpion3: dropPid=PID_SCORPION_TAIL; break;
	case NPC_PID_Brahmin:
	case NPC_PID_Brahmin2:
	case NPC_PID_Brahmin3:
	case NPC_PID_WeakBrahmin:
	case NPC_PID_WildBrahmin: if(valid(killer) && killer.Perk[PE_GECKO_SKINNING]!=0) dropPid=PID_BRAHMIN_SKIN; break;
	}
	if(dropPid!=0 && _CritCountItem(cr,dropPid)==0) _CritAddItem(cr,dropPid,1);

	// Karma, temporary
	if(valid(killer) && killer.IsPlayer())
	{
		int karmaBefore=killer.StatBase[ST_KARMA];
		uint team=cr.Stat[ST_TEAM_ID];
		//if(team==TEAM_Player) killer.StatBase[ST_KARMA]-=10;
		if(team==TEAM_Poorman) killer.StatBase[ST_KARMA]-=10;
		else if(team==TEAM_Narcoman) killer.StatBase[ST_KARMA]+=10;
		else if(team==TEAM_Citizen) killer.StatBase[ST_KARMA]-=10;
		else if(team==TEAM_Guard) killer.StatBase[ST_KARMA]-=10;
		else if(team==TEAM_PrivateGuard) killer.StatBase[ST_KARMA]-=10;
		else if(team==TEAM_Trader) killer.StatBase[ST_KARMA]-=10;
		else if(team==TEAM_Bandit) killer.StatBase[ST_KARMA]+=10;
		else if(team==TEAM_CasinoPlayer) killer.StatBase[ST_KARMA]-=10;
		else if(team==TEAM_CityElite) killer.StatBase[ST_KARMA]-=30;
		else if(team==TEAM_QuestNpc) killer.StatBase[ST_KARMA]-=30;
		else if(team==TEAM_Police) killer.StatBase[ST_KARMA]-=10;
		else if(team==TEAM_Slaver) killer.StatBase[ST_KARMA]+=10;
		else if(team==TEAM_Slave) killer.StatBase[ST_KARMA]-=10;
		else if(team==TEAM_Trapper) killer.StatBase[ST_KARMA]-=10;

		if(cr.Stat[ST_BODY_TYPE]==BT_CHILDREN) killer.KarmaBase[KARMA_CHILDKILLER]++;

		CallTownSupply(cr,killer); // Town supply call
	}

	SetReplicationTime(cr);
	if(cr.IsNpc()) cr.DropPlanes(); // Delete all planes
	if(valid(map) && cr.Mode[MODE_NO_FLATTEN]!=0)
	{
		Item@ blocker=map.AddItem(cr.HexX,cr.HexY,PID_UNVISIBLE_BLOCK,1);
		if(valid(blocker)) cr.StatBase[ST_DEAD_BLOCKER_ID]=blocker.Id;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reswapned.
void critter_respawn(Critter& cr)
{
	if(cr.Stat[ST_DEAD_BLOCKER_ID]!=0)
	{
		Item@ block=::GetItem(cr.Stat[ST_DEAD_BLOCKER_ID]);
		if(valid(block)) DeleteItem(block);
		cr.StatBase[ST_DEAD_BLOCKER_ID]=0;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on critter change item in active slot - Hands or Armor.
// If Item::CritSlot == 0xFF than item dropped/erased
void critter_change_item(Critter& cr, Item& item, uint8 fromSlot)
{
	uint8 toSlot=item.CritSlot;

	// Armor changing
	if(item.GetType()==ITEM_ARMOR && (fromSlot==SLOT_ARMOR || toSlot==SLOT_ARMOR))
	{
		if(not cr.IsAnim3d())
		{
			// Default dude
			bool isMale=(cr.Stat[ST_GENDER]==GENDER_MALE);
			uint crType=cr.Stat[ST_BASE_CRTYPE];
			if(crType==0) crType=(isMale?CRTYPE_DEFAULT_M:CRTYPE_DEFAULT_F);
			if(toSlot==SLOT_ARMOR) crType=(isMale?item.Proto.Armor_CrTypeMale:item.Proto.Armor_CrTypeFemale);

			// Long hair dude redirects
			if(cr.Stat[ST_BASE_CRTYPE]==CRTYPE_LHD_JUMPSUIT && isMale)
			{
				crType=CRTYPE_LHD_JUMPSUIT;
				if(toSlot==SLOT_ARMOR)
				{
					crType=item.Proto.Armor_CrTypeMale;
					if(crType==CRTYPE_DW_LEATHER_ARMOR_M) crType=CRTYPE_LHD_LEATHER_ARMOR;
					else if(crType==CRTYPE_DW_LEATHER_JACKET_M) crType=CRTYPE_LHD_LEATHER_JACKET;
					else if(crType==CRTYPE_DW_METAL_ARMOR_M) crType=CRTYPE_LHD_METAL_ARMOR;
				}
			}

			if(cr.CrType!=crType) cr.ChangeCrType(crType);
		}

		// Armor modifiers
		// Also look Armor perk validation in critter_init
		int sign=(toSlot==SLOT_ARMOR?int(1):-1);
		switch(item.Proto.Armor_Perk)
		{
		case ARMOR_PERK_POWERED: // +3 strength, +30 radiation resist
			cr.StatBase[ST_STRENGTH_EXT]+=3*sign;
			cr.StatBase[ST_RADIATION_RESISTANCE_EXT]+=30*sign;
			break;
		case ARMOR_PERK_COMBAT: // +20 radiation resist
			cr.StatBase[ST_RADIATION_RESISTANCE_EXT]+=20*sign;
			break;
		case ARMOR_PERK_ADVANCED_I: // +4 strength, +60 radiation resist
			cr.StatBase[ST_STRENGTH_EXT]+=4*sign;
			cr.StatBase[ST_RADIATION_RESISTANCE_EXT]+=60*sign;
			break;
		case ARMOR_PERK_ADVANCED_II: // +4 strength, +75 radiation resist
			cr.StatBase[ST_STRENGTH_EXT]+=4*sign;
			cr.StatBase[ST_RADIATION_RESISTANCE_EXT]+=75*sign;
			break;
		case ARMOR_PERK_CHARISMA: // +1 charisma
			cr.StatBase[ST_CHARISMA_EXT]+=1*sign;
			break;
		default:
			break;
		}
		cr.StatBase[ST_CURRENT_ARMOR_PERK]=(toSlot==SLOT_ARMOR?item.Proto.Armor_Perk:0);
	}

			// Slot modifiers
// SLOT_PERK_MIRROR_SHADES // +1 charisma
// SLOT_PERK_COSMETIC_CASE // +1 charisma to female
// SLOT_PERK_MOTION_SENSOR // +20 outdoorsman
// SLOT_PERK_STEALTH_BOY   // +20 sneak
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter in to map.
void map_critter_in(Map& map, Critter& cr)
{
	if(cr.IsPlayer())
	{
		uint16 locPid = map.GetLocation().GetProtoId();
		if(LOCATION_IS_CITY(locPid))
		{
			GameVar@ lastCityVar = GetLocalVar(LVAR_last_city, cr.Id);
			if (lastCityVar is null) return;
			lastCityVar = locPid;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter out from map.
void map_critter_out(Map& map, Critter& cr)
{
}

// Npc AI planes
#include "main_planes.fos"

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player votes for another.
// Already checked valid positions and timeout.
void karma_voting(Critter& crFrom, Critter& crTo, bool valUp)
{
	// Players karma system (not used)
	crTo.StatBase[ST_PLAYER_KARMA]+=(valUp?int(5):-10);
	crFrom.TimeoutBase[TO_KARMA_VOTING]=__FullSecond+REAL_HOUR(4); // 4 hours

/*	// Good / Evil system (not used)
	crFrom.TimeoutBase[TO_KARMA_VOTING]=__FullSecond+60; // Some small time to prevent bruteforce
	int crId=int(crTo.Id);
	// Find alredy added
	for(uint i=GOOD_EVIL_LIST_BEGIN;i<=GOOD_EVIL_LIST_END;i++)
	{
		int id=crFrom.GoodEvilList[i];
		if(id!=0)
		{
			bool isEvil=FLAG(id,0x80000000);
			if(isEvil) id^=0x80000000;

			if(id==crId)
			{
				if((valUp && not isEvil) || (not valUp && isEvil)) return; // Already added
				crFrom.GoodEvilListBase[i]=0; // Erase from list
				return;
			}
		}
	}
	// Add new record
	if(not valUp) crId|=0x80000000;
	for(uint i=GOOD_EVIL_LIST_BEGIN;i<=GOOD_EVIL_LIST_END;i++)
	{
		int id=crFrom.GoodEvilList[i];
		if(id==0)
		{
			crFrom.GoodEvilListBase[i]=crId;
			return;
		}
	}
	// All places busy, erase first 10
	for(uint i=GOOD_EVIL_LIST_BEGIN;i<=GOOD_EVIL_LIST_END-10;i++) crFrom.GoodEvilListBase[i]=crFrom.GoodEvilListBase[i+10];
	for(uint i=GOOD_EVIL_LIST_END-9;i<=GOOD_EVIL_LIST_END;i++) crFrom.GoodEvilListBase[i]=0;
	crFrom.GoodEvilListBase[GOOD_EVIL_LIST_END-10]=crId;*/
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine visibility of critters.
// To start working set flag LOOK_CHECK_SCRIPT to __LookChecks global var.
// Return true to allow see one critter another, false to disallow.
// Note: CRITTER_EVENT_SHOW_CRITTER_X, CRITTER_EVENT_HIDE_CRITTER_X is not processed.
bool check_look(Map& map, Critter& cr, Critter& opponent)
{
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost(Item& item, Critter& cr, Critter& npc, bool sell)
{
	return sell?1:2;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on barter transaction.
// Return false to cancel transaction.
bool items_barter(Item@[]& saleItems, uint[]& saleItemsCount, Item@[]& buyItems, uint[]& buyItemsCount, Critter& player, Critter& npc)
{
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player craft some items.
// Resources have None accessory and will be deleted after this function if no will be added to some place.
void items_crafted(Item@[]& items, uint[]& itemsCount, Item@[]& resources, Critter& crafter)
{
	// Find max wear value
	int maxWear=0;
	for(uint i=0,j=resources.length();i<j;i++)
	{
		Item@ item=resources[i];
		int wear=GetWearProcent(item);
		if(wear>maxWear) maxWear=wear;
	}

	for(uint i=0,j=items.length();i<j;i++)
	{
		// Unload weapons
		Item@ item=items[i];
		if(item.GetType()==ITEM_WEAPON && item.Proto.Weapon_VolumeHolder>0)
		{
			item.WeaponAmmoCount=0;
			item.Update();
		}

		// Set max wear value
		SetWear(item,maxWear);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Levelup callback.
void player_levelup(Critter& player, uint skillIndex, uint skillUp, uint perkIndex)
{
	if(skillIndex>=SKILL_BEGIN && skillIndex<=SKILL_END)
	{
		for(;skillUp!=0;skillUp--)
		{
			int skillVal=player.SkillBase[skillIndex];
			if(skillVal>=MAX_SKILL_VAL) break;

			int needPoints;
			if(skillVal<=100) needPoints=1;
			else if(skillVal>100 && skillVal<=125) needPoints=2;
			else if(skillVal>125 && skillVal<=150) needPoints=3;
			else if(skillVal>150 && skillVal<=175) needPoints=4;
			else if(skillVal>175 && skillVal<=200) needPoints=5;
			else needPoints=6;

			if(player.StatBase[ST_UNSPENT_SKILL_POINTS]<needPoints) break;

			skillVal++;
			if(_CritIsTagSkill(player,skillIndex) && skillVal<MAX_SKILL_VAL) skillVal++;
			player.SkillBase[skillIndex]=skillVal;
			player.StatBase[ST_UNSPENT_SKILL_POINTS]-=needPoints;
		}
	}
	else if(perkIndex>=PERK_BEGIN && perkIndex<=PERK_END)
	{
		if(PerkCheck(player,perkIndex))
		{
			player.PerkBase[perkIndex]++;
			player.StatBase[ST_UNSPENT_PERKS]--;
		}
	}

	player.StatBase[ST_REPLICATION_COST]=player.Stat[ST_LEVEL]*100;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Turn based callbacks.
// Called on every round begin, return false to disable turn-based
void turn_based_begin(Map& map)
{
	// Try end battle
	if(map.TurnBasedRound>0)
	{
		uint[] crittersIds;
		map.GetTurnBasedSequence(crittersIds);

		bool continueBattle=false;
		if(crittersIds.length()>=2)
		{
			for(uint i=0,j=crittersIds.length();i<j;i++)
			{
				Critter@ cr=::GetCritter(crittersIds[i]);
				if(!(not valid(cr) || cr.IsDead() ||
					(cr.IsNpc() && cr.GetPlanes(AI_PLANE_ATTACK,null)==0) ||
					(cr.IsPlayer() && (cr.Mode[MODE_END_COMBAT]!=0 || cr.Stat[ST_CURRENT_HP]<1))))
				{
					continueBattle=true;
					break;
				}
			}
		}

		if(not continueBattle) map.EndTurnBased();
	}
}

// Call on end turn-based battle
void turn_based_end(Map& map)
{
}

// Call on every begin and end turn
void turn_based_process(Map& map, Critter& cr, bool beginTurn)
{
}

// Call on world saving
// Range of currentIndex: 1..9999
void world_save(uint currentIndex, uint[]& deleteIndexes)
{
	// Keep only current and four last saves
	if(currentIndex==1)
	{
		deleteIndexes.resize(5);
		for(uint i=0;i<5;i++) deleteIndexes[i]=9999-i;
	}
	else if(currentIndex>4)
	{
		deleteIndexes.resize(1);
		deleteIndexes[0]=currentIndex-5;
	}
}

// Call on player try register
// Return true to allow, false to disallow
bool player_registration(uint ip, string& name, string& password, uint& textMsg, uint& strNum)
{
	return true;
}

// Call on player try login
// Return true to allow, false to disallow
bool player_login(uint ip, string& name, string& password, uint id, uint& textMsg, uint& strNum)
{
	if(__PermanentDeath>0 && IsPermanentDeath(id))
	{
		textMsg=TEXTMSG_GAME;
		strNum=STR_NET_PERMANENT_DEATH;
		return false;
	}
	return true;
}

// Call on player try change access
// Return true to allow, false to disallow
bool player_getaccess(Critter& player, int access, string& password)
{
	Log("Access changed for player "+player.Name+", from "+player.GetAccess()+" to "+access+".");
	return true;
}























