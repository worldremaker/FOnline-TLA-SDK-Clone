// Author: rifleman17

#include "_macros.fos"

#define LOC_PID_MIN 				(1)// начало диапазона кодов прототипов локаций
#define LOC_PID_MAX 				(LOCATION_PrimalTribe)// конец диапазона кодов прототипов локаций

#define BASE_LOC_PID1				(LOCATION_Vault15)//9 - эталонная начальная точка маршрута - используется при расчете экспы
#define BASE_LOC_PID2				(LOCATION_NCR) //10 - эталонная конечная точка маршрута - используется при расчете экспы

#define BASE_XP_LVL1				(500) // эталонная экспа первого уровня
#define BASE_XP_LVL2				(750) 
#define BASE_XP_LVL3				(950) 
#define BASE_XP_LVL4				(1200) 


#define LOC_NAME #(mapId)   		((mapId + 100) * 1000 )// поиск названия локации в файле FOGM.msg
#define NPC_NAME #(dialogId)   		((dialogId)*1000+100)// поиск имени НПЦ в файле FODLG.msg


// Почтальон выдает квест доставить письмо случайному адресату(нпц). Опыт рассчитывается в зависимости от расстояния между локацией, на которой стоит почтальон и локацией получателя.
// Чем выше уровень игрока, тем больше экспы он получит (и денег)
// можно отказаться от награды - персонаж не получит опыта и денег, но заработает +1 к карме
// на выдачу письма вешается таймаут. Величина таймаута зависит от навыка красноречия игрока.
// за базу был выбран коэффициент на основе выражения:  0 красноречия = неделя, 300 красноречия = 3 дня

#define TIME_Q #(speechLvl)			((7 -(4*speechLvl/300))*60*24)// расчет таймаута в минутах в зависисмоти от навыка красноречия

// случайное письмо
// startLoc - код прототипа стартовой локации (чтобы не было доставления письма в ту же локацию, этот прототип исключается из возможных вариантов)
LetterInfo @ GetRandomLetterInfo(uint startLoc)
{
	//Log("begin rSearch");
	uint locPid = startLoc;
	while (locPid==startLoc)
	{
		locPid = uint(Random(LOC_PID_MIN, LOC_PID_MAX));
		if (!LOCATION_IS_CITY(locPid)){locPid = startLoc;} // письма на военных базах некому доставить
		if (locPid==LOCATION_Arroyo){locPid = startLoc;}//TODO: убрать эту строку после того, как Арройо будет открыто полностью
		if (locPid==LOCATION_Navarro){locPid = startLoc;}//TODO: убрать эту строку после того, как Арройо будет открыто полностью
		if (locPid==LOCATION_Vault15){locPid = startLoc;}//TODO: убрать эту строку после того, как Арройо будет открыто полностью
	}

	Location @ loc = GetLocationByPid(locPid,0);
	if(!valid(loc)){return null;}

	if(loc.GetMapCount()==0){return null;}

	Map@[] maps;

	loc.GetMaps(maps);

	Map @ map = maps[uint(Random(0,uint(maps.length()-1)))];

	uint crNum = map.GetCritters(0, FIND_LIFE|FIND_ONLY_NPC, null);

	if(crNum==0){return null;}

	Critter@[] critters;
	map.GetCritters(0, FIND_LIFE|FIND_ONLY_NPC, critters);

	Critter @ cr = critters[Random(0, critters.length()-1)];

	if (cr.StatBase[ST_DIALOG_ID]==0){return null;}
	// крысам и браминам письма не шлем
	switch (cr.StatBase[ST_BODY_TYPE])
	{
		case BT_MEN:
			break;
		case BT_WOMEN:
			break;
		case BT_CHILDREN:
			break;
		case BT_SUPER_MUTANT:
			break;
		case BT_GHOUL:
			break;
		default:
			return null;
	}



	LetterInfo @li = LetterInfo();

	li.NpcDidRec = uint(cr.StatBase[ST_DIALOG_ID]);
	li.LocPidRec = locPid;
	li.MapPidRec = map.GetProtoId();

	critters.resize(0);

	//Log("end rSearch");

	return li;



}
// получает новое описание письма
// locPid - код локации, в которой начинаетсся квест
// playerId - id игрока
LetterInfo @ GetNewLetterInfo(uint locPid, uint playerId)
{
	uint numTry;
	numTry = 10;// максимально число попыток составить описание нового письма
	for (uint i = 0;i<numTry; i++)
	{
		LetterInfo @ li = GetRandomLetterInfo(locPid);
		if (valid(li))
		{
			li.PlayerID = playerId;
			li.LocPidStart = locPid;
			return li;
		}
	}
	Log("10 попыток создать письмо не увенчались успехом. / letter create fail after 10 tries");
	return null;
}
// Описание предмета - квестовое письмо для квеста "почтальон"
class LetterInfo
{

	LetterInfo()
	{

	}
	// создает экземпляр описания письма на основе итема
	LetterInfo(Item & item)
	{
		if(item.Val5==0){return;}

		this.LocPidStart = item.Val1;
		this.LocPidRec = item.Val2;
		this.MapPidRec = item.Val3;
		this.NpcDidRec = item.Val4;
		this.PlayerID  = item.Val5;
	}

	// pidLocS - PID локации на которой выдан квест
	// pidLocE - PID локации, на которой стоит нпц-получатель
	// pidMapE - PID карты, на которой стоит нпц получатель
	// didNpcE - номер диалога НПЦ-получателя
	// idPlayer - код игрока, выполняющего квест
	LetterInfo(uint pidLocS, uint pidLocE, uint pidMapE, uint didNpcE, uint idPlayer)
	{
		this.LocPidStart = pidLocS;
		this.LocPidRec = pidLocE;
		this.MapPidRec = pidMapE;
		this.NpcDidRec = didNpcE;
		this.PlayerID = idPlayer;
	}


	uint LocPidStart;	//PID локации, на которой выдается квест
	uint LocPidRec; 	//PID локации, где расположен получатель
	uint MapPidRec;		//PID карты, на которой расположен получатель
	uint NpcDidRec;		//PDialogID нпц-получателя
	uint PlayerID;		//Id игрока, выполняющего квест

	// сохраняет описание письма в итеме
	void SetItemLetterInfo(Item & item)
	{
		if(item.GetProtoId()!=PID_POSTMAN_LETTER){return;}

		item.Val1 = this.LocPidStart;
		item.Val2 = this.LocPidRec;
		item.Val3 = this.MapPidRec;
		item.Val4 = this.NpcDidRec;
		item.Val5 = this.PlayerID;

		item.SetLexems(this.GetLetterLexems());
		item.Update();
	}
	// лексемы для адреса/получателя письма
	string GetLetterLexems()
	{
		//Log("$reciever@msg DLG " + NPC_NAME(this.NpcDidRec) + " $location@msg GM "+ LOC_NAME(this.LocPidRec));
		return "$reciever@msg DLG " + NPC_NAME(this.NpcDidRec) + " @$location@msg GM "+ LOC_NAME(this.LocPidRec)+" @";
	}

	// рассчитывает количество опыта за выполнение квеста, в зависимости от уровня персонажа
	// lvl - уровень персонажа
	// playerID - Id персонажа
	uint GetExperience(uint lvl, uint playerID)
	{
		// квест взял другой игрок
		// Отменена проверка на доставщика
		//if (playerID!=this.PlayerID){return 0;}
		// определение базы для расчета ХР
		uint baseXP = 0;
		switch (uint(lvl/10))
		{
			case 0:// игроки ниже 10 ур
				baseXP = BASE_XP_LVL1;
				break;
			case 1:// игроки 10..19 ур
				baseXP = BASE_XP_LVL2;
				break;
			case 2:// игроки 20+ ур
				baseXP = BASE_XP_LVL3;
				break;
			default:
				baseXP = 0;
				break;
		}
		if(lvl>29)
			baseXP = BASE_XP_LVL4;
		

		// за базовое расстояние взят маршрут НКР-Волт15
		// для него нет проверки деления на ноль
		return uint((uint(baseXP*MeasureDist(this.LocPidStart, this.LocPidRec)/MeasureDist(uint(BASE_LOC_PID1), uint(BASE_LOC_PID2)))/100)*100);
	}


}

//вспомогательная функция - измеряет расстояние между двумя локациями с указанием прототипов локаций
float MeasureDist(uint pidLocFrom, uint pidLocTo)
{
	Location @ fromLoc = GetLocationByPid(pidLocFrom,0);
	if (!valid(fromLoc)){return 0;}
	Location @ toLoc = GetLocationByPid(pidLocTo,0);
	if (!valid(toLoc)){return 0;}
	return sqrt(POW2(toLoc.WorldX-fromLoc.WorldX)+POW2(toLoc.WorldY - fromLoc.WorldY));
}
//****************************************Скриптование предмета***************************//
// использование письма на криттера
bool e_OnMailUseOnCritter(Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery)
{

	if (!valid(onCritter)){return false;}
	if(onCritter.IsDead()){return false;}
	
	LetterInfo @li = LetterInfo(item);
	if(!valid(li))
	{


		return false;
	}
	//if(cr.Id!=li.PlayerID){return false;} сдать письмо может любой
	if(uint(onCritter.StatBase[ST_DIALOG_ID])!=li.NpcDidRec){return false;}

	if(!cr.IsPlayer()){return false;}

	// на всякий случай, проверяем, что игрок не враг нпц
	if(onCritter.CheckEnemyInStack(cr.Id)){return false;}

	// нужный нам нпц - тот самый, что прописан в итеме. Нужно открывать диалог получателя письма.
	// но диалог, открытый RunDialog'ом не имеет ссылки на нпц, поэтому сохраняем Id криттера нпц в специальную переменную
	GameVar @ crVar =  GetLocalVar(LVAR_ncr_mail_reciever_id, cr.Id);
	if(!valid(crVar)){return false;}

	crVar = onCritter.Id;

	RunDialog(cr,DIALOG_q_mail_reciever,onCritter.HexX,onCritter.HexY,false);

	return true;

}
// выброшенное письмо
void e_OnItemDrop(Item& item, Critter& cr)
{
	// если игрок выбрасывает письмо, переключаем квестовую переменную и стираем информацию о почтальоне
	// можно было бы и не стирать, но в этом случае игрок может накопить тонну конвертов и потом их сдавать оптом - мгновенная прокачка до космических высот
	GameVar @qVar = GetLocalVar(LVAR_q_mail_delivery, cr.Id);
	if (valid(qVar))
	{
		if (qVar.GetValue()==1)
		{
			qVar = 2;
			cr.SendQuestVar(qVar);
		}
	}
	LetterInfo @ li = LetterInfo(item);
	if (li.PlayerID == cr.Id)
	{
		li.PlayerID = 0;
		li.SetItemLetterInfo(item);
	}
}
// При выбросе итема.
// инициализация письма
void _LetterInit(Item & letter, bool firstTime)
{
	LetterInfo @ li = LetterInfo(letter);

	letter.SetEvent(ITEM_EVENT_DROP,"e_OnItemDrop");
	letter.SetEvent(ITEM_EVENT_USE,"e_OnMailUseOnCritter");
	letter.Update();
}
//**************************************Диалоги*******************************************//
// диалог с почтальоном, фраза в которой он называет адрес и получателя
void dlg_GenLetter2Postman(Critter& player, Critter@ postman, string@ lexems)
{


	// rifleman17: что эти проверки означают - не понял, но скопипастил из rangers_base dlg_GenBadPlName
	if(IS_DIALOG_END(lexems) or IS_DIALOG_SAY_MODE(lexems))
	{
		return;
	}

	// удаляем предыдущее письмо, если оно имеется
	if (postman.CountItem(PID_POSTMAN_LETTER)>0)
	{
		if (!postman.DeleteItem(PID_POSTMAN_LETTER,postman.CountItem(PID_POSTMAN_LETTER))){ Log("Old letter item delete fail");}
	}


	// устанавливаем почтальону запрет на воровство игроком, чтобы не крали письма в надежде сдать тучу сразу
	postman.ModeBase[MODE_NO_STEAL] = 1;
	postman.ModeBase[MODE_NO_BARTER] = 1;
	postman.ModeBase[MODE_NO_DROP] = 1;


	Item @ item = postman.AddItem(PID_POSTMAN_LETTER,1);
	if(!valid(item)){return;}


	LetterInfo @ li = GetNewLetterInfo(postman.GetMap().GetLocation().GetProtoId(), player.Id);
	li.SetItemLetterInfo(item);
	lexems = li.GetLetterLexems();
	//Log("Added lexems="+lexems+"а всего у нас "+postman.CountItem(PID_POSTMAN_LETTER));
}

// функция для использования в диалоге
// передача письма, которое уже есть в инвентаре почтальона игроку
void r_GiveLetter(Critter& player, Critter@ postman)
{

	Item @ letter = postman.GetItem(PID_POSTMAN_LETTER, -1);
	if(!valid(letter)){return;}
	LetterInfo @ li = LetterInfo(letter);
	if(!valid(li)){return;}

	Item @ newLetter = player.AddItem(PID_POSTMAN_LETTER,1);

	if(!valid(newLetter)){return;}
	li.SetItemLetterInfo(newLetter);
	newLetter.SetScript("ncr_postman@_LetterInit");
	postman.DeleteItem(PID_POSTMAN_LETTER,1);

}
// награждение игрока
// npc - получатель письма
void r_GrantPlayer(Critter& player, Critter@ npc_null, int needMoney)
{
	//npc_null - null, поскольку диалог открыт скриптом без выбора нпц
	GameVar @ crVar =  GetLocalVar(LVAR_ncr_mail_reciever_id, player.Id);
	if(!valid(crVar)){return;}

	Critter @ npc = GetCritter(crVar.GetValue());
	crVar = 0;// можно было и не обнулять, в принципе

	if (!valid(npc)){Log ("Npc mail reciever not found error");return;}


	if (!npc.IsLife()){return;}

	if(player.CountItem(PID_POSTMAN_LETTER)==0){return;}
	// писем может быть несколько, нам нужно именно наше
	Item@[] items;
	player.GetItems(-1,items);
	for (uint i = 0;i<items.length();i++)
	{
		Item @ letter = items[i];
		if (!valid(letter)){continue;}

		if (letter.GetProtoId()==PID_POSTMAN_LETTER)
		{
			LetterInfo @li = LetterInfo(letter);

			if(!valid(li)){continue;}

			if (li.NpcDidRec == uint(npc.StatBase[ST_DIALOG_ID]))
			{
				// получатель правильный - письмо можно удалять
				DeleteItem(letter);
				// если игрок правильный и у него активен квест ->(1,2) он получит экспу
				// иначе только деньги
				if(li.PlayerID==player.Id)
				{
					GameVar @qVar = GetLocalVar(LVAR_q_mail_delivery, player.Id);
					if (valid(qVar))
					{
						if (qVar.GetValue()>0&&qVar.GetValue()<3)
						{
							qVar = 3;
							player.SendQuestVar(qVar);
						}
					}
				}
				// все проверки закончены, итем удален
				// выдаем награду
				uint xp = li.GetExperience(player.StatBase[ST_LEVEL],player.Id);
				player.StatBase[ST_EXPERIENCE]+=xp;
				if(needMoney>0) player.AddItem(PID_BOTTLE_CAPS,xp!=0?CLAMP(uint(xp/2),0,2000):250);
				return;// выход из цикла и метода
			}
		}
	}
}
import bool d_RatchTimeOutCheck(Critter& player, Critter@ npc, int v0) from "ncr_ratch";
import void r_RatchTimeOutSet(Critter& player, Critter@ npc ,int v0, int v1) from "ncr_ratch";
// проверка: таймаут пустой или свободен
bool d_QTimeOutOK(Critter& player, Critter@ postman)
{
	return d_RatchTimeOutCheck(player, postman, LVAR_ncr_mail_timeout);
}
// таймаут занят
bool d_NotQTimeOutOK(Critter& player, Critter@ postman)
{
	return !d_QTimeOutOK(player, postman);
}
// установка таймаута
void r_SetQTimeOut(Critter& player, Critter@ postman)
{
	r_RatchTimeOutSet(player, postman, LVAR_ncr_mail_timeout, int(TIME_Q(player.SkillBase[SK_SPEECH])));
}










