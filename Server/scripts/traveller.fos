// Author: rifleman17
// Скрипт для реализации нпц-путешественников. 
// НПЦ перемещаются между различными городами по глобальной карте в случайном порядке.
// НПЦ либо честно идет по глобальной карте по прямой, и при заходе на энкаунтер разбирается с мобами, затем продолжает движение
// Либо просто телепортируется в следующую точку маршрута.
// НПЦ находится в каждом городе определенное время.
// Список точек маршрута и настройки нпц сохраняются в AnyData для каждого нпц.
// Следующая точка маршрута выбирается в момент достижения предыдущей.

#include "_macros.fos"
#include "serializator.fos"

#define TYPE_TRANSIT            (0) 
#define TYPE_TRAVEL             (1)
#define NEXT_TRY                (REAL_MINUTE(10))
#define CTE_FOUND_LOC           (11)
#define CTE_NEW_TRAVEL          (12)
#define DIST_MAX                (10) // Минимальная дистанция в гексах до криттера, находясь на которой игрок попадет ему в группу при начале путешествия
#define _AnyDataKey #(crId)("Traveller_"+crId)

//#define DL #(s) (Log("traveller: " + s))
#define DL #(s) 

// Присваевает скрипт для НПЦ и запускает его выполнение
// crId - Id нпц
// isTransit - признак, нпц перемещается телепортом
// entireNum - номер гекса, на который будет перемещаться нпц при заходе в локацию
// timeWaitLoc - время ожидания на локации до следующего путешествия
// timeWaitEnc - время ожидания на энкаунтере после завершения боя до продолжения путешествия
// locPids - массив кодов протоипов локаций, на которые может зайти НПЦ
void SetTraveller(uint crId, bool isTransit, uint entireNum, uint timeWaitLoc, uint timeWaitEnc, uint16[] locPids, bool visibleEncounters) // Export
{
	Critter@ cr = GetCritter(crId);
	if(!valid(cr))
		return;
	cr.ModeBase[MODE_GECK] = 1;
	cr.ModeBase[MODE_NO_HOME] = 1;
	Traveller@ t = Traveller(crId);
	t.TravelType = ( isTransit ? TYPE_TRANSIT : TYPE_TRAVEL);
	t.EntireTo = entireNum;
	t.TimeWaitLocation = timeWaitLoc;
	t.TimeWaitEncounter = timeWaitEnc;
	t.VisibleEncounters = visibleEncounters;
	for(uint i = 0, l = locPids.length(); i < l; i++)
	{
		t.AddLocPid(locPids[i]);
	}
	t.Save();
	if(valid(cr.GetMap()))
	{
		t.SheduleChooseLocation();
		t.SheduleTravel(true);
	}
	if (t.TravelType == TYPE_TRAVEL)
	{
		cr.SetEvent(CRITTER_EVENT_GLOBAL_INVITE, "_GlobalInvite");
		cr.SetEvent(CRITTER_EVENT_GLOBAL_PROCESS, "_GlobalProcess");
	}
}

void CancelTraveller(uint crId)
{
	Traveller@ ti = Traveller(crId);
	ti.Erase();
	Critter@ cr = GetCritter(crId);
	if(!valid(cr))
		return;
	if(cr.GetTimeEvents(CTE_FOUND_LOC, null, null, null) != 0)
		cr.EraseTimeEvents(CTE_FOUND_LOC);
	if(cr.GetTimeEvents(CTE_NEW_TRAVEL, null, null, null) != 0)
		cr.EraseTimeEvents(CTE_NEW_TRAVEL);

}

class Traveller
{
	Traveller(uint crId)
	{
		this.CritterId = crId;
	}
	
	uint     CritterId;         // Id нпц-путешественника
	uint8    TravelType;        // Тип перемещений.(Телепорт или путешествие через глобал)
	uint     MapIdTo;           // Id карты на которую направляется НПЦ
	uint     EntireTo;          // Номер гекса, на котором будет стоять НПЦ
	uint     TimeWaitLocation;  // Время ожидания в игровых секундах на локации перед следующим путешествием
	uint     TimeWaitEncounter; // Время ожидания в игровых секундах на энкаунтере во время путешествия
	bool     VisibleEncounters; // Признак - делать ли энкаунтер видимым, если на него зашел НПЦ	
	uint16[] LocationPids;      // Массив кодов прототипов локаций, на которые может отправиться НПЦ
	uint[]   Followers;         // Массив Id спутников путешественника, может быть как игроки, так и нпц
	
	void AddLocPid(uint16 locPid)
	{
		for(uint i = 0, l = this.LocationPids.length(); i < l; i++)
		{
			if(locPid ==this.LocationPids[i])
				return;
		}
		ArrayPushBack(this.LocationPids, locPid);
	}
	
	void AddFollower(uint crId)
	{
		for(uint i = 0, l = this.Followers.length(); i < l; i++)
		{
			if(crId ==this.Followers[i])
				return;
		}
		ArrayPushBack(this.Followers, crId);	
		this.Save();
	}
	
	// Сериализация
	
	void Save()
	{
		Serializator save;
		save.Set(this.CritterId);
		save.Set(this.TravelType);
		save.Set(this.MapIdTo);
		save.Set(this.EntireTo);
		save.Set(this.TimeWaitLocation);
		save.Set(this.TimeWaitEncounter);
		save.Set(this.VisibleEncounters);
		save.Set(this.LocationPids);
		save.Set(this.Followers);
		save.Save(_AnyDataKey(this.CritterId));
	}
	
	void Load()
	{
		Serializator load;
		if(!load.Load(_AnyDataKey(this.CritterId)))
			return;
		load.Get(this.CritterId);
		load.Get(this.TravelType);
		load.Get(this.MapIdTo);
		load.Get(this.EntireTo);
		load.Get(this.TimeWaitLocation);
		load.Get(this.TimeWaitEncounter);
		load.Get(this.VisibleEncounters);
		load.Get(this.LocationPids);
		load.Get(this.Followers);
	}
	
	void Erase()
	{
		string key = _AnyDataKey(this.CritterId);
		if(IsAnyData(key))
			EraseAnyData(key);
	}
	
	Critter@ GetTraveller()
	{
		if(this.CritterId == 0)
			return null;
		return GetCritter(this.CritterId);
	}
	
	// Попытка найти новую точку перемещения
	bool TryFoundNewLocation()
	{
		int tries = 20;
		uint idx = 0;
		uint len = this.LocationPids.length();
		uint maps = 0;
		if(len == 0)
			return false;
		Critter@ cr = this.GetTraveller();
		if(!valid(cr))
			return false;
		uint mapId = 0;
		Map@ mapCr = cr.GetMap();
		if(valid(mapCr))
			mapId = mapCr.Id;
		while(tries > 0)
		{
			idx = Random(0, len - 1);
			Location@[] locations;
			GetAllLocations(this.LocationPids[idx], locations);
			if(locations.length() > 0)
			{
				idx = Random(0, locations.length() - 1);
				Location@ loc = locations[idx];
				if(valid(loc))
				{
					maps = loc.GetMapCount();
					for(uint i = 0; i < maps; i++)
					{
						Map@ map = loc.GetMapByIndex(i);
						if(valid(map) && (map.CountEntire(this.EntireTo) > 0) && map.Id != mapId)
						{
							DL("Target point found. Id = " + map.Id + "; ProtoMap = " + map.GetProtoId());
							this.MapIdTo = map.Id;
							this.Save();
							return true;
						}
					}
				}
			}
			tries--;
		}
		DL("Travel point not found");
		return false;
	}
	
	bool TransitToLocation()
	{
		Critter@ cr = this.GetTraveller();
		//DL("found critter");
		if(!valid(cr) || this.MapIdTo == 0)
			return false;
		//DL("mapId>0 , cr.valid/MapIdTo" + this.MapIdTo + "; entire: "+this.EntireTo);
		Map@ map = GetMap(this.MapIdTo);
		if(!valid(map) || map.CountEntire(this.EntireTo) == 0)
			return false;
		//	DL("map ok");
		if(cr.TransitToMap(this.MapIdTo, this.EntireTo))
		{
			return true;
		}
		//DL("transit failed");
		return false;
	}
	
	// Собирает группу желающих и выходит на глобал
	// Если человек, желающий сопровождать нпц находится дальше DIST_MAX от нпц, в группу не попадает
	bool BeginTravelToLocation()
	{
		Critter@ cr = this.GetTraveller();
		if(!valid(cr))
			return false;
		Map@ map = cr.GetMap();
		if(!valid(map))
			return false;
		Critter@[] grp;
		uint[] confirmedIds;
		push_back_handle(grp, cr);
		uint ch = cr.Stat[ST_CHARISMA];
		for(uint i = 0, l = this.Followers.length(); i < l && confirmedIds.length() < ch; i++)
		{
			Critter@ follower = GetCritter(this.Followers[i]);
			if(valid(follower) && valid(follower.GetMap()) && (follower.GetMap().Id == map.Id) && (GetCrittersDistantion(cr, follower) <= DIST_MAX))
			{
				push_back_handle(grp, follower);
				ArrayPushBack(confirmedIds, follower.Id);
			}
		}
		this.Followers.resize(0);
		for(uint i = 0, l = confirmedIds.length(); i < l; i++)
		{
			ArrayPushBack(this.Followers, confirmedIds[i]);
		}
		cr.TransitToGlobal(grp);
		return true;
	}
	
	void SheduleChooseLocation()
	{
		Critter@ cr = this.GetTraveller();
		if(!valid(cr))
			return;
		if(cr.GetTimeEvents(CTE_FOUND_LOC, null, null, null) == 0)
			cr.AddTimeEvent("cte_ChooseTravelPoint", 0, CTE_FOUND_LOC);
	}
	
	void SheduleTravel(bool fromLoc)
	{
		Critter@ cr = this.GetTraveller();
		if(!valid(cr))
			return;
		if(cr.GetTimeEvents(CTE_NEW_TRAVEL, null, null, null) == 0)
			cr.AddTimeEvent("cte_Travel", (fromLoc ? this.TimeWaitLocation : this.TimeWaitEncounter), CTE_NEW_TRAVEL);
	}
	
	// Проверка маршрута и уточнение координат конечной точки маршрута
	// Актуально только для TYPE_TRAVEL
	bool ValidateRoute(uint16& worldX, uint16& worldY)
	{
		if(this.MapIdTo == 0)
			return false;
		Map@ map = GetMap(this.MapIdTo);
		if(!valid(map))
			return false;
		Location@ loc = map.GetLocation();
		if(!valid(loc))
			return false;
		uint16 x = loc.WorldX;;
		uint16 y = loc.WorldY;
		return true;
	}
}

Traveller@ TravellerFromCritter(uint crId)
{
	string key = _AnyDataKey(crId);
	if(!IsAnyData(key))
		return null;
	Traveller@ t = Traveller(crId);
	t.Load();
	return t;	
}

// Начало путешествия. Либо телепорт, либо переход по глобалу
uint cte_Travel(Critter& cr, int identifier, uint& rate)
{
	if(!cr.IsNoPlanes() || !valid(cr.GetMap()))
		return NEXT_TRY;	
	Traveller@ t = TravellerFromCritter(cr.Id);
	if(valid(t))
	{
		if(t.TravelType == TYPE_TRANSIT)
		{
			if(!t.TransitToLocation())
			{
				DL("Error, can't transit to new location");
				return NEXT_TRY;
			}
			else
			{
				t.SheduleChooseLocation();				
				t.SheduleTravel(true);
			}
		}
		else
		{
			if(!t.BeginTravelToLocation())
			{
				DL("Error, can't begin travel to new location");
				return NEXT_TRY;
			}
		}
	}
	return 0;
}

// Поиск новой точки маршрута нпц, производится при заходе в локацию
uint cte_ChooseTravelPoint(Critter& cr, int identifier, uint& rate)
{
	Traveller@ t = TravellerFromCritter(cr.Id);
	if(valid(t))
	{
		if(!t.TryFoundNewLocation())
		{
			DL("cannot foun new location");
			return NEXT_TRY;
		}
	}
	return 0;
}

// Обработка событий
bool _GlobalProcess(Critter& cr, int type, Critter@[]& group, Item@ car, uint& x, uint& y, uint& toX, uint& toY, uint& speed, uint& encounterDescriptor, bool& waitForAnswer)
{
	DL("type: " + type + "; coords " + x + ":" + y + "; pointTo " + toX + ":" + toY);
	Traveller@ t = TravellerFromCritter(cr.Id);
	if(valid(t) && type == GLOBAL_PROCESS_STOPPED)
	{
		if(t.ValidateRoute(toX, toY))
		{
			if(toX == x && toY == y)
			{
				if(cr.TransitToMap(t.MapIdTo, t.EntireTo))
				{
					t.Followers.resize(0);					
					t.SheduleChooseLocation();
					t.SheduleTravel(true);
					return true;
				}
			}
		}
		else
		{
			t.SheduleChooseLocation();
		}
	}
	return false;
}

bool _GlobalInvite(Critter& cr, Critter@[]& group, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir)
{
	DL("global invite");
	Traveller@ t = TravellerFromCritter(cr.Id);
	if(valid(t))
	{
		t.SheduleTravel(false);	
		Map@ map = GetMap(mapId);
		if(valid(map))
		{
			Location@ loc = map.GetLocation();
			if(valid(loc) && loc.AutoGarbage && t.VisibleEncounters)
				loc.Visible = true;
		}
	}
	return false;
}

// Диалоги
void r_AddFollower(Critter& player, Critter@ npc)
{
	if(!valid(npc))
		return;
	Traveller@ t = TravellerFromCritter(npc.Id);
	if(!valid(t))
		return;
	if(valid(t))
	{
		t.AddFollower(player.Id);
	}
}

// Проверка, находится ли нпц на энкаунтере или в одной из локаций маршрута
bool d_OnEncounter(Critter& player, Critter@ npc)
{
	if(!valid(npc))
		return false;
	Traveller@ t = TravellerFromCritter(npc.Id);
	if(valid(t))
	{
		Map@ map = npc.GetMap();
		if(!valid(map)) 
			return false;
		Location@ loc = map.GetLocation();
		if(!valid(loc))
			return false;
		return loc.AutoGarbage;
	}
	return false;
}

bool d_NotOnEncounter(Critter& player, Critter@ npc)
{
	if(!valid(npc))
		return false;
	Traveller@ t = TravellerFromCritter(npc.Id);
	if(valid(t))
	{
		Map@ map = npc.GetMap();
		if(!valid(map)) 
			return false;
		Location@ loc = map.GetLocation();
		if(!valid(loc))
			return false;
		return !loc.AutoGarbage;
	}
	return false;
}