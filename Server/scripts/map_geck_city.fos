// Author: rifleman17
// Скрипты для города, который можно построить, использовав ГЕКК.
// ГЭКК нужно использовать на пустынном энкаунтере (LOCATION_DesertEncounter1..LOCATION_DesertEncounter12)
#include "_macros.fos"
#include "entire.fos"

#define STR_WRONG_LOC                               (5500) // Это место совершенно не подходит для строительства города из Г.Э.К.К.
#define STR_WRONG_PASS                              (5501) // Код неверный. Активация отменена.
#define STR_RIGHT_PASS                              (5502) // Код принят. Начат процесс активации Г.Э.К.К.а.
#define STR_ACCESS_LEADER                           (5503) // Сохранены сведения о жителе Города. Имя: @lex pname@
#define STR_ACCESS_MEMBER                           (5504) // Поздравляем! Ваши сведения записаны в базу данных Города. Вы получите расширенный доступ ко всем системам.
#define STR_CREATION_END                            (5505) // Работа Генератора Эдемских Кущ Компактного завершена. Добро пожаловать в Город из Г.Э.К.К.а!
#define STR_CANT_OPEN_DOOR                          (5506) // Электронный замок на этой двери невозможно открыть стандартными способами. От отмычек или динамита не будет никакого толку.
#define STR_CITIZEN_ADDED                           (5507) // @lex leadername@ включил вас в списки жителей Города из Г.Э.К.К. 
#define STR_CITIZEN_REMOVED                         (5508) // @lex leadername@ исключил вас из списка жителей Города из Г.Э.К.К.
#define STR_GENERATOR_CHARGED                       (5509) // Генератор заряжен, всего зарядов: @lex charges@. Примерное время бесперебойной работы барьера, часов: @lex time@.
#define LOC_PID_GECK_CITY                           (LOCATION_GeckCity)
#define GECK_CITY_KEY #(locId)                      ("GeckCity"+locId+"_members")
#define GECK_DOOR_KEY #(mapId)                      ("GeckCity"+mapId+"_door")// Не более одной двери на одну карту
#define GECK_GENERATOR_KEY #(locId)                 ("GeckCity"+locId+"_generator")
#define GECK_LEADER_KEY #(locId)                    ("GeckCity"+locId+"_leader")
#define DIALOG_DOOR_COMPUTER                        (DIALOG_geck_door_comp) // Диалог с компьютером, управляющим дверью c наружной стороны
#define CLOSE_DOOR_TIME                             (__FullSecond+(60*20)) // Время в игровых секундах до автоматического закрытия двери. (одна реальная минута
#define VAR_CITIZEN                                 (LVAR_gcity_citizen) // Номер переменной, по которой будет проверяться, житель ли это города из ГЕКК или нет
                                                         // В этой переменной сохраняется Id локации с городом из Гекка
#define HOMEPOS_RADIUS                              (10) // Радиус, в котором от домашней позиции должен находиться НПЦ, чтобы считалось, что он добрался до места.
#define XP_CREATE_CITY                              (25000) // Опыт за создание города
#define FORCE_DIALOG_PLAYER_NOTFOUND                (10) // Номер строки диалога с главным компьютером города, в котором пишется, что игрок не найден
#define FORCE_DIALOG_PLAYER_ADDED                   (7) // Номер строки диалога с главным компьютером города, в котором пишется, что игрок добавлен в списки жителей города
#define FORCE_DIALOG_PLAYER_REMOVED                 (8) // Номер строки диалога с главным компьютером города, в котором пишется, что игрок удален из списков жителей города
#define FORCE_DIALOG_ERROR                          (9) // Неизвестная ошибка
#define ENTIRE_CITYHALL                             (17) // Номер гекса на который перемещается житель при входе в город.
#define ENTIRE_DOCTOR                               (18) // Номер гекса клиники, в которую можно привести доктора.
#define MAPLOOP_0                                   (65000) // Период, на который тратится 1 батарейка в генераторе, при расчете: активен барьер на входе или нет
#define CHARGES_INDEX                               (0) // Индекс в map.Data, в котором хранится число заряженных в генератор батареек
#define _GetCharges #(map)                          (map.GetData(CHARGES_INDEX))
#define _SetCharges #(map, charges)                 (map.SetData(CHARGES_INDEX, charges))
#define _GetUptime # (charges)                      (uint(charges*(MAPLOOP_0/1000)/3600)) // Время в часах игровое в зависимости от числа зарядов
#define CHARGES_MFC                                 (10) // Число зарядов генератора c одного реактора
#define CHARGES_CEC                                 (1) // Число зарядов генератора c одной малой батареи
#define MAX_CELLS                                   (100) // Максимальное число батареек за раз, которые можно загрузить в генератор
#define GATES_NET_NUM                               (1) // Номер сети для барьера на входе. 
#define CITIZENS_TRADING_SKILL                      (10) // Навык бартера для нпц-торговца в ГизГ
// energy_barrier.fos
#define BM_OFF                                      (1)
#define BM_ON                                       (0)

import uint8 GetNetState(uint mapId, uint netNum) from "energy_barier";
import void _TraderInit(Critter& trader, bool firstTime) from "trader";

// Выдача ГЕККА игроку с присвоением скрипта
void r_GiveGeck(Critter & cr, Critter @ npc)
{
	Item @ geck = cr.AddItem(PID_GECK,1);
	if(valid(geck))
	{
		geck.SetScript("_GeckInit");
	}
}

void _GeckInit(Item& geck, bool firstTime)
{
	SETFLAG(geck.Flags, ITEM_CAN_USE);
	geck.SetEvent(ITEM_EVENT_USE, "_GeckUse");
}

bool _GeckUse(Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery)
{
	if(valid(onItem)||valid(onCritter)||valid(onScenery)) return false;
	Map @ map = cr.GetMap();
	if(!valid(map)) return false;
	Location @ loc = map.GetLocation();
	if(!valid(loc)) return false;
	if(!loc.AutoGarbage) return false;
	uint locPid = loc.GetProtoId();
	if(locPid<LOCATION_DesertEncounter1||locPid>LOCATION_DesertEncounter12)
	{
		cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_WRONG_LOC);
		return true;
	}
	CreateCity(cr, item);
	return true;
}

void CreateCity(Critter & player, Item & geck)
{
	DeleteItem(geck);
	Critter @[] grp;
	Critter @ leader = player.GetFollowLeader();
	if(!valid(leader)) @leader = player;
	ArrayPushBack(grp,leader);
	leader.GetFollowGroup(FIND_LIFE, grp);
	uint locId = CreateLocation(LOC_PID_GECK_CITY, player.WorldX, player.WorldY, grp);
	if(locId==0) return;
	Location @ loc = GetLocation(locId);
	if(!valid(loc)) return;
	loc.AutoGarbage = false;
	loc.Visible = true;
	loc.Radius = 6;
	uint[] acceptedPlayers;
	for(uint i=0,l=grp.length();i<l;i++)
	{
		Critter @ cr = grp[i];
		if(!valid(cr)) continue;
		if(!cr.IsPlayer()) continue;
		GameVar @ geckCitizen = GetLocalVar(VAR_CITIZEN, cr.Id);
		if(geckCitizen>0) continue; // Невозможно быть жителем двух городов одновременно
		geckCitizen = loc.Id;
		ArrayPushBack(acceptedPlayers, cr.Id);
		leader.SayMsg(SAY_NETMSG,TEXTMSG_TEXT,STR_ACCESS_LEADER, "$pname"+GetPlayerName(cr.Id));
		cr.SayMsg(SAY_NETMSG,TEXTMSG_TEXT,STR_ACCESS_MEMBER);
		cr.StatBase[ST_EXPERIENCE]+=XP_CREATE_CITY;
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 3480, "$exp" + XP_CREATE_CITY );
	}
	uint[] chief = {player.Id};	
	player.SayMsg(SAY_NETMSG,TEXTMSG_TEXT,STR_CREATION_END);
	leader.TransitToGlobal(grp);
	player.AddItem(PID_USED_GECK, 1);
	SetAnyData(GECK_LEADER_KEY (locId),chief);
	SetAnyData(GECK_CITY_KEY(locId), acceptedPlayers);
}

// Проверка, является ли криттер жителем данного города из ГЕККА
bool IsPlayerCitizen(Critter @ cr)
{
	if(!valid(cr)) return false;
	Map @ map = cr.GetMap();
	if(!valid(map)) return false;
	Location @ loc = map.GetLocation();
	if(!valid(loc)) return false;
	string key = GECK_CITY_KEY(loc.Id);
	if(!IsAnyData(key)) return false;
	uint[] acceptedPlayers;
	if(!GetAnyData(key,acceptedPlayers)) return false;
	for(uint i=0,l=acceptedPlayers.length();i<l;i++)
	{
		if(cr.Id == acceptedPlayers[i]) return true;
	}
	return false;	
}

// Проверка, является ли криттер лидером данного города из ГЕККА
// Лидер может исключать или удалять игрока из списка жителей города
bool IsPlayerLeader(Critter @ cr)
{
	if(!valid(cr)) return false;
	Map @ map = cr.GetMap();
	if(!valid(map)) return false;
	Location @ loc = map.GetLocation();
	if(!valid(loc)) return false;
	string key = GECK_LEADER_KEY(loc.Id);
	if(!IsAnyData(key)) return false;
	uint[] chief;
	if(!GetAnyData(key,chief)) return false;
	return chief[0]==cr.Id;	
}

// Добавление игрока в списки жителей
bool AddCitizen(Critter & leader, Critter & player)
{
	if(!valid(leader)) return false;
	Map @ map = leader.GetMap();
	if(!valid(map)) return false;
	Location @ loc = map.GetLocation();
	if(!valid(loc)) return false;
	string key = GECK_CITY_KEY(loc.Id);
	if(!IsAnyData(key)) return false;
	uint[] acceptedPlayers;
	if(!GetAnyData(key,acceptedPlayers)) return false;
	for(uint i=0,l=acceptedPlayers.length();i<l;i++)
	{
		if(player.Id == acceptedPlayers[i]) return true;
	}
	GameVar @ cityMember = GetLocalVar(VAR_CITIZEN, player.Id);
	if(!valid(cityMember)) return false;
	if(cityMember.GetValue()!=0) return false;
	cityMember = loc.Id;
	ArrayPushBack(acceptedPlayers, player.Id);
	EraseAnyData(key);
	SetAnyData(key, acceptedPlayers);	
	return true;	
}

// Исключение игрока из списков жителей
bool RemoveCitizen(Critter & leader, Critter & player)
{
	if(!valid(leader)) return false;
	Map @ map = leader.GetMap();
	if(!valid(map)) return false;
	Location @ loc = map.GetLocation();
	if(!valid(loc)) return false;
	string key = GECK_CITY_KEY(loc.Id);
	if(!IsAnyData(key)) return false;
	uint[] acceptedPlayers;
	if(!GetAnyData(key,acceptedPlayers)) return false;
	for(uint i=0,l=acceptedPlayers.length();i<l;i++)
	{
		if(player.Id == acceptedPlayers[i])
		{
			remove_from_array(acceptedPlayers,i);
			EraseAnyData(key);
			SetAnyData(key, acceptedPlayers);	
			GameVar @ cityMember = GetLocalVar(VAR_CITIZEN, player.Id);
			if(!valid(cityMember)) return true;
			if(cityMember.GetValue()!=0) cityMember=0;
			return true;
		}
	}
	return false;
}

// Работа со списком жителей города
bool d_IsPlayerLeader(Critter & player, Critter @ none)
{
	return IsPlayerLeader(player);
}	

void dlg_RemoveCitizen(Critter& player, Critter@ npc, string@ playerName)
{
	if(!IS_DIALOG_SAY_MODE(playerName)) return;
	Critter@ cr=GetPlayer(playerName);
	if(valid(cr))
	{
		if(cr.Id==player.Id)
		{
			__ForceDialog=FORCE_DIALOG_PLAYER_NOTFOUND;
			return;
		}
		if(RemoveCitizen(player, cr))
		{			
			cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_CITIZEN_REMOVED, "$leadername"+GetPlayerName(player.Id));
			__ForceDialog=FORCE_DIALOG_PLAYER_REMOVED;
			return;
		}else{
			__ForceDialog=FORCE_DIALOG_ERROR;
			return;
		}
	}
	__ForceDialog=FORCE_DIALOG_PLAYER_NOTFOUND;
}

void dlg_AddCitizen(Critter& player, Critter@ npc, string@ playerName)
{
	if(!IS_DIALOG_SAY_MODE(playerName)) return;
	Critter@ cr=GetPlayer(playerName);
	if(valid(cr))
	{
		if(cr.Id==player.Id)
		{
			__ForceDialog=FORCE_DIALOG_PLAYER_NOTFOUND;
			return;
		}
		if(AddCitizen(player, cr))
		{			
			cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_CITIZEN_ADDED , "$leadername"+GetPlayerName(player.Id));
			__ForceDialog=FORCE_DIALOG_PLAYER_ADDED;
			return;
		}else{
			__ForceDialog=FORCE_DIALOG_ERROR;
			return;
		}
	}	
	__ForceDialog=FORCE_DIALOG_PLAYER_NOTFOUND;
}

// Двери центрального здания (Штабквартиры)
// К штабквартире имеют доступ только граждане города. Гражданами считаются те, кто был в группе, установившей ГЕКК, а также добавленные лидером позже.
bool s_UseDoorComputer(Critter& player, Scenery& scenery, int skill, Item@ item)
{
	if(valid(item)||skill!=SKILL_PICK_ON_GROUND) return true;
	return RunDialog(player, uint16(DIALOG_DOOR_COMPUTER), scenery.HexX, scenery.HexY, false);
}

bool d_IsCitizen(Critter & player, Critter @ npc)
{
	return IsPlayerCitizen(player);
}

bool d_NotCitizen(Critter & player, Critter @ npc)
{
	return !d_IsCitizen(player, npc);
}

void _DoorInit(Item& door, bool firstTime)
{
	Map @ map = GetMap(door.MapId);
	if(valid(map))
	{
		Location @ loc = map.GetLocation();
		if(valid(loc))
		{
			string key = GECK_DOOR_KEY(map.Id);
			uint [] data = {door.Id};
			SetAnyData(key, data);
		}
	}
	door.SetEvent(ITEM_EVENT_SKILL,"_DoorSkill");
}

bool _DoorSkill(Item& door, Critter& cr, int skill)
{
	if(FLAG(door.LockerCondition,LOCKER_ISOPEN)) return false;	
	cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_CANT_OPEN_DOOR);
	return true;
}

void r_OpenDoor(Critter & player, Critter @ none)
{
	Item @ door = GetGeckDoor(player.GetMap());
	if(!valid(door)) return;
	door.LockerOpen();	
	CreateTimeEvent(CLOSE_DOOR_TIME,"item@e_AutoCloseDoor", door , true);	
}

void r_CloseDoor(Critter & player, Critter @ none)
{
	Item @ door = GetGeckDoor(player.GetMap());
	if(!valid(door)) return;
	door.LockerClose();
}

Item@ GetGeckDoor(Map @ map)
{
	if(!valid(map)) return null;
	Location @ loc = map.GetLocation();
	if(!valid(loc)) return null;
	string key = GECK_DOOR_KEY(map.Id);
	if(!IsAnyData(key)) return null;
	uint[] data;
	if(!GetAnyData(key,data)) return null;
	return GetItem(data[0]);	
}

// Найм НПЦ для службы в своем городе из ГЕККа. 
// Нанимать можно только одного НПЦ за раз. 
// НПЦ будет следовать за игроком, пока тот не приведет его к месту назначения
Location @ GetGeckLocation(Critter @ player)
{
	if(!valid(player)) return null;
	GameVar @ location = GetLocalVar(VAR_CITIZEN, player.Id);
	if(!valid(location)) return null;
	if(location==0) return null;
	return(GetLocation(location.GetValue()));	
}

// Проверка, может ли игрок нанять НПЦ для службы в своем городе
// npcPid - прототип НПЦ
// maxNum - максимальное число НПЦ такого типа на карте
// homeEntire - номер гекса с домашней позицией НПЦ
bool d_CanHireNpc(Critter & player, Critter @ npc, int npcPid, int maxNum, int homeEntire)
{
	if(maxNum<1) return false;
	Location @ loc = GetGeckLocation(player);
	if(!valid(loc)) return false;
	// На данный момент, локация Город из ГЕККА состоит только из двух карт. 
	// НПЦ могут находиться только на первой из них.
	Map @ map = loc.GetMapByIndex(0);
	if(!valid(map)) return false;
	uint count = map.GetCritters(uint16(npcPid), FIND_ALL, null);
	if(count>=uint(maxNum)) return false;
	return (map.CountEntire(uint8(homeEntire))>count);	
}

bool d_CanNotHireNpc(Critter & player, Critter @ npc, int npcPid, int maxNum, int homeEntire)
{
	return (!d_CanHireNpc(player, npc, npcPid, maxNum, homeEntire));
}

bool d_CanHireNpc(Critter & player, Critter @ npc, int maxNum, int homeEntire)
{
	if(!valid(npc)) return false;
	int npcPid = npc.GetProtoId();
	return d_CanHireNpc(player, npc, npcPid, maxNum, homeEntire);
}

bool d_CanNotHireNpc(Critter & player, Critter @ npc, int maxNum, int homeEntire)
{
	return (!d_CanHireNpc(player, npc, maxNum, homeEntire));
}

// Проверка, найдена ли новая домашняя позиция в Городе из ГЕККа для НПЦ
// homeEntire - номер гекса с домашней позицией НПЦ 
bool d_HomeFound(Critter & player, Critter @ npc, int homeEntire)
{
	if(!valid(npc)) return false;
	Location @ loc = GetGeckLocation(player);
	if(!valid(loc)) return false;
	Map @ map = loc.GetMapByIndex(0);
	if(!valid(map)) return false;
	Map @ npc_map = npc.GetMap();
	if(!valid(npc_map)) return false;
	if(map.Id!=npc_map.Id) return false;
	Entire[] entires;
	uint count = ParseEntires(map, entires, homeEntire);
	if(count==0) return false;
	for(uint i=0, l=entires.length();i<l;i++)
	{
		if(GetDistantion(npc.HexX, npc.HexY, entires[i].HexX, entires[i].HexY)<=HOMEPOS_RADIUS) return true;
	}
	return false;	
}

bool d_NotHomeFound(Critter & player, Critter @ npc, int homeEntire)
{
	return (!d_HomeFound(player, npc, homeEntire));
}

// Установка новой домашней позиции для НПЦ рядом с ближайшим Entire гексом
// homeEntire - номер гекса с домашней позицией НПЦ
void r_SetNewHome(Critter & player, Critter @ npc, int homeEntire)
{
	if(!valid(npc)) return;
	Map @ map = npc.GetMap();
	if(!valid(map)) return;
	Entire[] entires;
	uint count = ParseEntires(map, entires, homeEntire);
	if(count==0) return;
	for(uint i=0, l=entires.length();i<l;i++)
	{
		if(GetDistantion(npc.HexX, npc.HexY, entires[i].HexX, entires[i].HexY)<=HOMEPOS_RADIUS) 
		{
			npc.SetHomePos(entires[i].HexX, entires[i].HexY, GetDirection(entires[i].HexX, entires[i].HexY, npc.HexX, npc.HexY));
			return;
		}
	}
}

// Скрипт карты
void _MapInit(Map & map, bool firstTime)
{
	map.SetEvent(MAP_EVENT_IN_CRITTER, "_GeckMapInCritter");
	map.SetEvent(MAP_EVENT_LOOP_0, "_GeckMapLoop1");
	map.SetLoopTime(0, MAPLOOP_0);
}

void _GeckMapLoop1(Map& map)
{
	if(GetNetState(map.Id,GATES_NET_NUM)==BM_ON)
	{
		uint charges = _GetCharges(map);
		if(charges>0)
		{
			charges--;
			_SetCharges(map, charges);
		}else{
			uint[] values = {GATES_NET_NUM,map.Id};
			CreateTimeEvent(__FullSecond,"energy_barier@e_DisableForceField",values,false);
		}
	}
}

// Жители сразу попадают в штабквартиру, если заходят на карту города из ГЕККа
void _GeckMapInCritter(Map& map, Critter& cr)
{
	if(cr.IsPlayer()) 
	{
		if(IsPlayerCitizen(cr)) 
		{
			uint16 hx=0;
			uint16 hy=0;
			if (GetEntireFreeHex(map, ENTIRE_CITYHALL, hx, hy))
			{
				cr.TransitToHex(hx, hy, Random(0,5));
			}
		}
	}
}

// Энергобарьер на карте города из ГЭКК требует подпитки батареями
bool d_HasGeneratorCharges(Critter & player, Critter @ npc)
{
	Map @ map = player.GetMap();
	if(!valid(map)) return false;
	return (_GetCharges(map)>0);
}

bool d_NoGeneratoreCharges(Critter & player, Critter @ npc)
{
	Map @ map = player.GetMap();
	if(!valid(map)) return false;
	return (_GetCharges(map)<1);
}

// Использование батарей на генератор
bool s_UseGenerator(Critter& cr, Scenery& scen, int skill, Item@ item)
{
	if(!valid(item)) return false;
	Map @ map = cr.GetMap();
	if(!valid(map)) return false;
	uint itemPid = item.GetProtoId();
	uint charges = 0;
	uint itemCount = CLAMP(item.GetCount(),0,MAX_CELLS);
	switch (itemPid)
	{
		case PID_SMALL_ENERGY_CELL:
			charges = CHARGES_CEC*itemCount;
			break;
		case PID_MICRO_FUSION_CELL:
			charges = CHARGES_MFC*itemCount;
			break;
		default:
			break;
	}
	if(charges==0) return false;
	charges = _GetCharges(map)+charges;
	_SetCharges(map, charges);
	cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_GENERATOR_CHARGED, "$charges"+charges+"$time"+_GetUptime(charges));	
	_SubItem (item,itemCount);
	return true;
}

bool d_BarrierOn(Critter & player, Critter @ npc)
{
	Map @ map = player.GetMap();
	if(!valid(map)) return false;
	return (GetNetState(map.Id,GATES_NET_NUM)==BM_ON);
}

bool d_BarrierOff(Critter & player, Critter @ npc)
{
	Map @ map = player.GetMap();
	if(!valid(map)) return false;
	return (GetNetState(map.Id,GATES_NET_NUM)==BM_OFF);
}

void r_SwitchBarrierMode(Critter & player, Critter @ npc, int mode)
{
	Map @ map = player.GetMap();
	if(!valid(map)) return;
	uint[] values = {GATES_NET_NUM,map.Id};
	CreateTimeEvent(__FullSecond,(mode==BM_ON?"energy_barier@e_EnableForceField":"energy_barier@e_DisableForceField"),values,false);
}

// Общий скрипт для торговца на карте ГЕККа. Торговец должен быть прописан в trader_table.fos
void _GeckTraderInit(Critter & cr, bool firstTime)
{
	_TraderInit(cr, firstTime);
	cr.SetEvent(CRITTER_EVENT_BARTER, "_GeckTraderBarter");
}

bool _GeckTraderBarter(Critter& cr, Critter& player, bool attach, uint barterCount)
{
	// Для сохранения оригинального значения навыка торговли НПЦ используется VAR_0
	if(cr.Stat[ST_VAR0]==0) cr.StatBase[ST_VAR0] = cr.Skill[SK_BARTER];
	if(attach&&barterCount<2&&IsPlayerCitizen(player))
	{
		cr.SkillBase[SK_BARTER] = CITIZENS_TRADING_SKILL;
	}else{
		cr.SkillBase[SK_BARTER] = cr.Stat[ST_VAR0];		
	}
	return true;
}

// Debug
void AddGeck(Critter & cr, int,int,int)
{
	Item@ geck = cr.AddItem(PID_GECK,1);
	if(valid(geck))
	{
		geck.SetScript("_GeckInit");
	}
}